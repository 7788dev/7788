// src/node/plugins/getPlugins.ts
import { activeHeaderLinksPlugin } from "@vuepress/plugin-active-header-links";
import { docsearchPlugin } from "@vuepress/plugin-docsearch";
import { gitPlugin } from "@vuepress/plugin-git";
import { photoSwipePlugin } from "@vuepress/plugin-photo-swipe";
import { nprogressPlugin } from "@vuepress/plugin-nprogress";
import { iconifyPlugin } from "@vuepress-plume/plugin-iconify";
import { shikiPlugin } from "@vuepress-plume/plugin-shikiji";
import { commentPlugin } from "@vuepress/plugin-comment";
import { mdEnhancePlugin } from "vuepress-plugin-md-enhance";
import { readingTimePlugin } from "@vuepress/plugin-reading-time";
import { seoPlugin } from "@vuepress/plugin-seo";
import { sitemapPlugin } from "@vuepress/plugin-sitemap";
import { contentUpdatePlugin } from "@vuepress-plume/plugin-content-update";
import { searchPlugin } from "@vuepress-plume/plugin-search";
import { markdownPowerPlugin } from "vuepress-plugin-md-power";
import { watermarkPlugin } from "@vuepress/plugin-watermark";
import { fontsPlugin } from "@vuepress-plume/plugin-fonts";

// src/node/utils/index.ts
import { Logger } from "@vuepress/helper";

// src/node/utils/hash.ts
import { createHash } from "node:crypto";
import { customAlphabet } from "nanoid";
var hash = (content) => createHash("md5").update(content).digest("hex");
var nanoid = customAlphabet("0123456789abcdefghijklmnopqrstuvwxyz", 8);

// src/node/utils/path.ts
import { getDirname, path } from "vuepress/utils";
import { ensureEndingSlash, ensureLeadingSlash, isLinkAbsolute, isLinkWithProtocol } from "@vuepress/helper";
var __dirname = getDirname(import.meta.url);
var resolve = (...args) => path.resolve(__dirname, "../", ...args);
var templates = (url) => resolve("../templates", url);
var RE_SLASH = /(\\|\/)+/g;
function normalizePath(path9) {
  return path9.replace(RE_SLASH, "/");
}
function pathJoin(...args) {
  return normalizePath(path.join(...args));
}
function normalizeLink(base, link = "") {
  return isLinkAbsolute(link) || isLinkWithProtocol(link) ? link : ensureLeadingSlash(normalizePath(`${base}/${link}/`));
}
var RE_START_END_SLASH = /^\/|\/$/g;
function getCurrentDirname(basePath, filepath) {
  const dirList = normalizePath(basePath || path.dirname(filepath)).replace(RE_START_END_SLASH, "").split("/");
  return dirList.length > 0 ? dirList[dirList.length - 1] : "";
}
function withBase(path9 = "", base = "/") {
  path9 = ensureEndingSlash(ensureLeadingSlash(path9));
  if (path9.startsWith(base))
    return normalizePath(path9);
  return normalizePath(`${base}${path9}`);
}

// src/node/utils/package.ts
import process from "node:process";
import { fs, path as path2 } from "vuepress/utils";
function getPackage() {
  let pkg = {};
  try {
    const content = fs.readFileSync(path2.join(process.cwd(), "package.json"), "utf-8");
    pkg = JSON.parse(content);
  } catch {
  }
  return pkg;
}
function getThemePackage() {
  let pkg = {};
  try {
    const content = fs.readFileSync(resolve(".../../package.json"), "utf-8");
    pkg = JSON.parse(content);
  } catch {
  }
  return pkg;
}

// src/node/utils/resolveContent.ts
function resolveContent(app, { name, content, before, after }) {
  content = `${before ? `${before}
` : ""}export const ${name} = ${JSON.stringify(content)}${after ? `
${after}` : ""}`;
  if (app.env.isDev) {
    const func = `update${name[0].toUpperCase()}${name.slice(1)}`;
    content += `

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.${func}) {
    __VUE_HMR_RUNTIME__.${func}(${name})
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ ${name} }) => {
    __VUE_HMR_RUNTIME__.${func}(${name})
  })
}
`;
  }
  return content;
}

// src/node/utils/writeTemp.ts
var contentHash = /* @__PURE__ */ new Map();
async function writeTemp(app, filepath, content) {
  const currentHash = hash(content);
  if (!contentHash.has(filepath) || contentHash.get(filepath) !== currentHash) {
    contentHash.set(filepath, currentHash);
    await app.writeTemp(filepath, content);
  }
}

// src/node/utils/index.ts
var THEME_NAME = "vuepress-theme-plume";
var logger = new Logger(THEME_NAME);

// src/node/config/resolveThemeOption.ts
function resolveThemeOptions({
  themePlugins,
  plugins,
  hostname,
  configFile,
  ...localeOptions
}) {
  const pluginOptions = plugins ?? themePlugins ?? {};
  if (themePlugins) {
    logger.warn(
      `The 'themePlugins' option is deprecated. Please use 'plugins' instead.`
    );
  }
  return {
    configFile,
    pluginOptions,
    hostname,
    localeOptions
  };
}

// src/node/config/resolveLocaleOptions.ts
import { entries, fromEntries, getLocaleConfig } from "@vuepress/helper";

// src/node/locales/zh.ts
var zhLocale = {
  selectLanguageName: "\u7B80\u4F53\u4E2D\u6587",
  selectLanguageText: "\u9009\u62E9\u8BED\u8A00",
  appearanceText: "\u5916\u89C2",
  lightModeSwitchTitle: "\u5207\u6362\u4E3A\u6D45\u8272\u4E3B\u9898",
  darkModeSwitchTitle: "\u5207\u6362\u4E3A\u6DF1\u8272\u4E3B\u9898",
  outlineLabel: "\u6B64\u9875\u5185\u5BB9",
  returnToTopLabel: "\u8FD4\u56DE\u9876\u90E8",
  editLinkText: "\u7F16\u8F91\u6B64\u9875",
  contributorsText: "\u8D21\u732E\u8005",
  prevPageLabel: "\u4E0A\u4E00\u9875",
  nextPageLabel: "\u4E0B\u4E00\u9875",
  lastUpdated: {
    text: "\u6700\u540E\u66F4\u65B0\u4E8E"
  },
  notFound: {
    code: "404",
    title: "\u9875\u9762\u672A\u627E\u5230",
    quote: "\u4F46\u662F\uFF0C\u5982\u679C\u4F60\u4E0D\u6539\u53D8\u65B9\u5411\uFF0C\u5E76\u4E14\u4E00\u76F4\u5BFB\u627E\uFF0C\u6700\u7EC8\u53EF\u80FD\u4F1A\u5230\u8FBE\u4F60\u8981\u53BB\u7684\u5730\u65B9\u3002",
    linkText: "\u8FD4\u56DE\u9996\u9875"
  },
  encryptButtonText: "\u786E\u8BA4",
  encryptPlaceholder: "\u8BF7\u8F93\u5165\u5BC6\u7801",
  encryptGlobalText: "\u672C\u7AD9\u53EA\u5141\u8BB8\u5BC6\u7801\u8BBF\u95EE",
  encryptPageText: "\u672C\u9875\u9762\u53EA\u5141\u8BB8\u5BC6\u7801\u8BBF\u95EE",
  footer: {
    message: 'Power by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var zhPresetLocale = {
  home: "\u9996\u9875",
  blog: "\u535A\u5BA2",
  tag: "\u6807\u7B7E",
  archive: "\u5F52\u6863",
  category: "\u5206\u7C7B"
};
var zhDocsearchLocale = {
  placeholder: "\u641C\u7D22\u6587\u6863",
  translations: {
    button: {
      buttonText: "\u641C\u7D22\u6587\u6863",
      buttonAriaLabel: "\u641C\u7D22\u6587\u6863"
    },
    modal: {
      searchBox: {
        resetButtonTitle: "\u6E05\u9664\u67E5\u8BE2\u6761\u4EF6",
        resetButtonAriaLabel: "\u6E05\u9664\u67E5\u8BE2\u6761\u4EF6",
        cancelButtonText: "\u53D6\u6D88",
        cancelButtonAriaLabel: "\u53D6\u6D88"
      },
      startScreen: {
        recentSearchesTitle: "\u641C\u7D22\u5386\u53F2",
        noRecentSearchesText: "\u6CA1\u6709\u641C\u7D22\u5386\u53F2",
        saveRecentSearchButtonTitle: "\u4FDD\u5B58\u81F3\u641C\u7D22\u5386\u53F2",
        removeRecentSearchButtonTitle: "\u4ECE\u641C\u7D22\u5386\u53F2\u4E2D\u79FB\u9664",
        favoriteSearchesTitle: "\u6536\u85CF",
        removeFavoriteSearchButtonTitle: "\u4ECE\u6536\u85CF\u4E2D\u79FB\u9664"
      },
      errorScreen: {
        titleText: "\u65E0\u6CD5\u83B7\u53D6\u7ED3\u679C",
        helpText: "\u4F60\u53EF\u80FD\u9700\u8981\u68C0\u67E5\u4F60\u7684\u7F51\u7EDC\u8FDE\u63A5"
      },
      footer: {
        selectText: "\u9009\u62E9",
        navigateText: "\u5207\u6362",
        closeText: "\u5173\u95ED",
        searchByText: "\u641C\u7D22\u63D0\u4F9B\u8005"
      },
      noResultsScreen: {
        noResultsText: "\u65E0\u6CD5\u627E\u5230\u76F8\u5173\u7ED3\u679C",
        suggestedQueryText: "\u4F60\u53EF\u4EE5\u5C1D\u8BD5\u67E5\u8BE2",
        reportMissingResultsText: "\u4F60\u8BA4\u4E3A\u8BE5\u67E5\u8BE2\u5E94\u8BE5\u6709\u7ED3\u679C\uFF1F",
        reportMissingResultsLinkText: "\u70B9\u51FB\u53CD\u9988"
      }
    }
  }
};
var zhSearchLocale = {
  placeholder: "\u641C\u7D22\u6587\u6863",
  resetButtonTitle: "\u91CD\u7F6E\u641C\u7D22",
  backButtonTitle: "\u5173\u95ED",
  noResultsText: "\u65E0\u641C\u7D22\u7ED3\u679C\uFF1A",
  footer: {
    selectText: "\u9009\u62E9",
    selectKeyAriaLabel: "\u8F93\u5165",
    navigateText: "\u5207\u6362",
    navigateUpKeyAriaLabel: "\u5411\u4E0A",
    navigateDownKeyAriaLabel: "\u5411\u4E0B",
    closeText: "\u5173\u95ED",
    closeKeyAriaLabel: "\u9000\u51FA"
  }
};

// src/node/locales/en.ts
var enLocale = {
  selectLanguageName: "English",
  selectLanguageText: "Languages",
  appearanceText: "Appearance",
  lightModeSwitchTitle: "Switch to light theme",
  darkModeSwitchTitle: "Switch to dark theme",
  editLinkText: "Edit this page",
  contributorsText: "Contributors",
  lastUpdated: {
    text: "Last Updated"
  },
  encryptButtonText: "Confirm",
  encryptPlaceholder: "Enter password",
  encryptGlobalText: "Only password can access this site",
  encryptPageText: "Only password can access this page",
  footer: {
    message: 'Power by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
var enPresetLocale = {
  home: "Home",
  blog: "Blog",
  tag: "Tags",
  archive: "Archives",
  category: "Categories"
};
var enSearchLocale = {
  placeholder: "Search",
  resetButtonTitle: "Reset search",
  backButtonTitle: "Close search",
  noResultsText: "No results for",
  footer: {
    selectText: "to select",
    selectKeyAriaLabel: "enter",
    navigateText: "to navigate",
    navigateUpKeyAriaLabel: "up arrow",
    navigateDownKeyAriaLabel: "down arrow",
    closeText: "to close",
    closeKeyAriaLabel: "escape"
  }
};

// src/node/locales/index.ts
var LOCALE_OPTIONS = {
  "/zh/": zhLocale,
  "/en/": enLocale
};
var PRESET_LOCALES = {
  "/zh/": zhPresetLocale,
  "/en/": enPresetLocale
};
var DOCSEARCH_LOCALES = {
  "/zh/": zhDocsearchLocale
};
var SEARCH_LOCALES = {
  "/zh/": zhSearchLocale,
  "/en/": enSearchLocale
};

// src/node/config/resolveLocaleOptions.ts
var FALLBACK_OPTIONS = {
  appearance: true,
  blog: {
    link: "/blog/",
    pagination: { perPage: 15 },
    tags: true,
    archives: true,
    categories: true,
    tagsLink: "/blog/tags/",
    archivesLink: "/blog/archives/",
    categoriesLink: "/blog/categories/"
  },
  article: "/article/",
  notes: { link: "/", dir: "/notes/", notes: [] },
  navbarSocialInclude: ["github", "twitter", "discord", "facebook"],
  aside: true,
  outline: [2, 3],
  // page meta
  editLink: true,
  contributors: true,
  footer: {
    message: 'Power by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a>'
  }
};
function resolveLocaleOptions(app, { locales, ...options }) {
  const resolvedOptions = {
    ...FALLBACK_OPTIONS,
    ...options,
    locales: getLocaleConfig({
      app,
      name: THEME_NAME,
      default: LOCALE_OPTIONS,
      config: fromEntries(
        entries({
          "/": {},
          ...locales
        }).map(([locale, opt]) => [
          locale,
          { ...options, ...opt }
        ])
      )
    })
  };
  return resolvedOptions;
}

// src/node/config/resolveThemeData.ts
import { entries as entries2, getRootLangPath } from "@vuepress/helper";
var EXCLUDE_LIST = ["locales", "sidebar", "navbar", "notes", "sidebar", "article", "avatar"];
var EXCLUDE_LOCALE_LIST = [...EXCLUDE_LIST, "blog", "appearance"];
function resolveThemeData(app, options) {
  const themeData = { locales: {} };
  const root = getRootLangPath(app);
  entries2(options).forEach(([key, value]) => {
    if (!EXCLUDE_LIST.includes(key))
      themeData[key] = value;
  });
  if (options.avatar) {
    themeData.profile ??= options.avatar;
  }
  entries2(options.locales || {}).forEach(([locale, opt]) => {
    themeData.locales[locale] = {};
    entries2(opt).forEach(([key, value]) => {
      if (!EXCLUDE_LOCALE_LIST.includes(key))
        themeData.locales[locale][key] = value;
    });
    if (opt.avatar) {
      themeData.locales[locale].profile ??= opt.avatar;
    }
  });
  const blog = options.blog || {};
  const blogLink = blog.link || "/blog/";
  entries2(options.locales || {}).forEach(([locale, opt]) => {
    if (opt.navbar !== false && (!opt.navbar || opt.navbar.length === 0)) {
      const localePath = locale === "/" ? root : locale;
      const navbar = [{
        text: PRESET_LOCALES[localePath].home,
        link: locale
      }];
      navbar.push({
        text: PRESET_LOCALES[localePath].blog,
        link: withBase(blogLink, locale)
      });
      if (blog.tags !== false) {
        navbar.push({
          text: PRESET_LOCALES[localePath].tag,
          link: withBase(blog.tagsLink || `${blogLink}/tags/`, locale)
        });
      }
      if (blog.archives !== false) {
        navbar.push({
          text: PRESET_LOCALES[localePath].archive,
          link: withBase(blog.archivesLink || `${blogLink}/archives/`, locale)
        });
      }
      themeData.locales[locale].navbar = navbar;
    } else {
      themeData.locales[locale].navbar = opt.navbar;
    }
  });
  return themeData;
}

// src/node/config/resolveProvideData.ts
import { entries as entries3, fromEntries as fromEntries2, getRootLangPath as getRootLangPath2, isPlainObject } from "@vuepress/helper";
function resolveProvideData(app, plugins) {
  const root = getRootLangPath2(app);
  return {
    // 注入水印配置
    __PLUME_WM_FP__: isPlainObject(plugins.watermark) ? plugins.watermark.fullPage !== false : true,
    // 注入多语言配置
    __PLUME_PRESET_LOCALE__: fromEntries2(
      entries3(PRESET_LOCALES).map(([locale, value]) => [locale === root ? "/" : locale, value])
    )
  };
}

// src/node/config/resolveAlias.ts
import { fs as fs2, path as path3 } from "vuepress/utils";
function resolveAlias() {
  return {
    ...Object.fromEntries(
      fs2.readdirSync(
        resolve("client/components"),
        { encoding: "utf-8", recursive: true }
      ).filter((file) => file.endsWith(".vue")).map((file) => [
        path3.join("@theme", file),
        resolve("client/components", file)
      ])
    )
  };
}

// src/node/config/extendsBundlerOptions.ts
import {
  addViteConfig,
  addViteOptimizeDepsExclude,
  addViteOptimizeDepsInclude,
  addViteSsrNoExternal,
  chainWebpack
} from "@vuepress/helper";
function extendsBundlerOptions(bundlerOptions, app) {
  addViteConfig(bundlerOptions, app, {
    build: {
      chunkSizeWarningLimit: 1024
    }
  });
  addViteOptimizeDepsInclude(bundlerOptions, app, "@vueuse/core", true);
  addViteOptimizeDepsExclude(bundlerOptions, app, "@theme");
  addViteSsrNoExternal(bundlerOptions, app, [
    "@vuepress/helper",
    "@vuepress/plugin-reading-time",
    "@vuepress/plugin-watermark"
  ]);
  chainWebpack(bundlerOptions, app, (config) => {
    config.module.rule("scss").use("sass-loader").tap((options) => ({
      api: "modern-compiler",
      ...options,
      sassOptions: {
        silenceDeprecations: ["mixed-decls"],
        ...options.sassOptions
      }
    }));
  });
  addViteConfig(bundlerOptions, app, {
    css: {
      preprocessorOptions: {
        sass: {
          logger: {
            warn: (message, { deprecation, deprecationType }) => {
              if (deprecation && deprecationType.id === "mixed-decls")
                return;
              console.warn(message);
            }
          }
        },
        scss: {
          logger: {
            warn: (message, { deprecation, deprecationType }) => {
              if (deprecation && deprecationType.id === "mixed-decls")
                return;
              if (!message.includes("repetitive deprecation warnings omitted")) {
                console.warn(message);
              }
            }
          }
        }
      }
    }
  });
}

// src/node/config/templateBuildRenderer.ts
import { templateRenderer } from "vuepress/utils";
function templateBuildRenderer(template, context) {
  const pkg = getThemePackage();
  template = template.replace("{{ themeVersion }}", pkg.version || "").replace(/^\s+|\s+$/gm, "").replace(/\n/g, "");
  return templateRenderer(template, context);
}

// src/node/config/resolveSearchOptions.ts
import { getLocaleConfig as getLocaleConfig2 } from "@vuepress/helper";
function resolveSearchOptions(app, { locales, ...options } = {}) {
  return {
    ...options,
    locales: getLocaleConfig2({
      app,
      default: SEARCH_LOCALES,
      config: locales
    })
  };
}
function resolveDocsearchOptions(app, { locales, ...options } = {}) {
  return {
    ...options,
    locales: getLocaleConfig2({
      app,
      default: DOCSEARCH_LOCALES,
      config: locales
    })
  };
}

// src/node/config/resolvePageHead.ts
function resolvePageHead(page, localeOptions) {
  page.frontmatter.head ??= [];
  if (localeOptions.appearance ?? true) {
    const appearance = typeof localeOptions.appearance === "string" ? localeOptions.appearance : "auto";
    page.frontmatter.head.push([
      "script",
      { id: "check-dark-mode" },
      appearance === "force-dark" ? `document.documentElement.classList.add('dark')` : `;(function () {
        const um= localStorage.getItem('vuepress-theme-appearance') || '${appearance}';
        const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (um === 'dark' || (um !== 'light' && sm)) {
          document.documentElement.classList.add('dark');
        }
      })();`.replace(/^\s+|\s+$/gm, "").replace(/\n/g, "")
    ]);
  }
  page.frontmatter.head?.push([
    "script",
    { id: "check-mac-os" },
    `document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))`
  ]);
}

// src/node/config/resolveNotesOptions.ts
import { entries as entries4 } from "@vuepress/helper";
import { uniq } from "@pengzhanbo/utils";
function resolveNotesLinkList(localeOptions) {
  const locales = localeOptions.locales || {};
  const notesLinks = [];
  for (const [locale, opt] of entries4(locales)) {
    const config = locale === "/" ? opt.notes || localeOptions.notes : opt.notes;
    if (config && config.notes?.length) {
      const prefix = config.link || "";
      notesLinks.push(
        ...config.notes.map(
          (note) => withBase(`${prefix}/${note.link || ""}`, locale)
        )
      );
    }
  }
  return uniq(notesLinks);
}
function resolveNotesOptions(localeOptions) {
  const locales = localeOptions.locales || {};
  const notesOptionsList = [];
  for (const [locale, opt] of entries4(locales)) {
    const options = locale === "/" ? opt.notes || localeOptions.notes : opt.notes;
    if (options) {
      options.dir = withBase(options.dir, locale);
      notesOptionsList.push(options);
    }
  }
  return notesOptionsList;
}

// src/node/plugins/containerPlugins.ts
import { markdownContainerPlugin as containerPlugin } from "@vuepress/plugin-markdown-container";
var customContainerPlugins = [
  /**
   * :::demo-wrapper img no-padding title="xxx" height="100px"
   * :::
   */
  containerPlugin({
    type: "demo-wrapper",
    before(info) {
      const title = resolveAttr(info, "title");
      const wrapperClasses = ["demo-wrapper"];
      let containerStyle = "";
      if (title)
        wrapperClasses.push("has-title");
      if (info.includes("img"))
        wrapperClasses.push("only-img");
      if (info.includes("no-padding"))
        wrapperClasses.push("no-padding");
      const height = resolveAttr(info, "height");
      if (height) {
        const h = Number.parseFloat(height) === Number(height) ? `${height}px` : height;
        containerStyle += `--demo-container-height: ${h};`;
        wrapperClasses.push("has-height");
      }
      return `<div class="${wrapperClasses.join(" ")}">
  <div class="demo-head">
    <div class="demo-ctrl"><i></i><i></i><i></i></div>
    ${title ? `<h4 class="demo-title"><p>${title}</p></h4>` : ""}
  </div>
  <div class="demo-container" ${containerStyle ? `style="${containerStyle}"` : ""}>
`;
    },
    after() {
      return "</div></div>\n";
    }
  }),
  /**
   * :::steps
   * 1. 步骤 1
   *    xxx
   * 2. 步骤 2
   *    xxx
   * 3. ...
   * :::
   */
  containerPlugin({
    type: "steps",
    before() {
      return '<div class="vp-steps">';
    },
    after() {
      return "</div>";
    }
  }),
  /**
   * ::: card title="xxx" icon="xxx"
   * xxx
   * :::
   */
  containerPlugin({
    type: "card",
    before(info) {
      const title = resolveAttr(info, "title");
      const icon = resolveAttr(info, "icon");
      return `<VPCard${title ? ` title="${title}"` : ""}${icon ? ` icon="${icon}"` : ""}>`;
    },
    after() {
      return "</VPCard>";
    }
  }),
  /**
   * :::: card-grid
   * ::: card
   * xxx
   * :::
   * ::: card
   * xxx
   * :::
   * ::::
   */
  containerPlugin({
    type: "card-grid",
    before() {
      return "<VPCardGrid>";
    },
    after() {
      return "</VPCardGrid>";
    }
  })
];
function resolveAttr(info, attr) {
  const pattern = `\\b${attr}\\s*=\\s*(?<quote>['"])(?<content>.+?)\\k<quote>(\\s|$)`;
  const regex = new RegExp(pattern, "i");
  const match = info.match(regex);
  return match?.groups?.content ?? null;
}

// src/node/plugins/getPlugins.ts
function getPlugins({
  app,
  pluginOptions,
  hostname
}) {
  const isProd = !app.env.isDev;
  const plugins = [
    iconifyPlugin(),
    fontsPlugin(),
    contentUpdatePlugin(),
    activeHeaderLinksPlugin({
      headerLinkSelector: "a.outline-link",
      headerAnchorSelector: ".header-anchor",
      delay: 200,
      offset: 20
    }),
    ...customContainerPlugins
  ];
  if (pluginOptions.readingTime !== false) {
    plugins.push(readingTimePlugin({
      locales: {
        "/zh/": {
          word: "$word\u5B57",
          less1Minute: "\u5C0F\u4E8E1\u5206\u949F",
          time: "\u7EA6$time\u5206\u949F"
        }
      },
      ...pluginOptions.readingTime
    }));
  }
  if (pluginOptions.nprogress !== false) {
    plugins.push(nprogressPlugin());
  }
  if (pluginOptions.git ?? isProd) {
    plugins.push(gitPlugin({
      createdTime: false,
      updatedTime: true,
      contributors: true
    }));
  }
  if (pluginOptions.photoSwipe !== false) {
    plugins.push(photoSwipePlugin({
      selector: ".plume-content > img, .plume-content :not(a) > img",
      delay: 300
    }));
  }
  if (pluginOptions.docsearch) {
    if (pluginOptions.docsearch.appId && pluginOptions.docsearch.apiKey)
      plugins.push(docsearchPlugin(resolveDocsearchOptions(app, pluginOptions.docsearch)));
    else
      console.error("docsearch plugin: appId and apiKey are both required");
  } else if (pluginOptions.search !== false) {
    plugins.push(searchPlugin(resolveSearchOptions(app, pluginOptions.search)));
  }
  const shikiOption = pluginOptions.shiki;
  let shikiTheme = { light: "vitesse-light", dark: "vitesse-dark" };
  if (shikiOption !== false) {
    shikiTheme = shikiOption?.theme ?? shikiTheme;
    plugins.push(shikiPlugin({
      theme: shikiTheme,
      ...shikiOption ?? {}
    }));
  }
  if (pluginOptions.markdownEnhance !== false) {
    plugins.push(mdEnhancePlugin(
      Object.assign(
        {
          hint: true,
          // info note tip warning danger details
          codetabs: true,
          tabs: true,
          align: true,
          mark: true,
          tasklist: true,
          attrs: true,
          sup: true,
          sub: true,
          alert: true,
          footnote: true,
          katex: true
        },
        pluginOptions.markdownEnhance || {}
      )
    ));
  }
  if (pluginOptions.markdownPower !== false) {
    plugins.push(markdownPowerPlugin({
      caniuse: pluginOptions.caniuse,
      ...pluginOptions.markdownPower || {},
      repl: pluginOptions.markdownPower?.repl ? { theme: shikiTheme, ...pluginOptions.markdownPower?.repl } : pluginOptions.markdownPower?.repl
    }));
  }
  if (pluginOptions.watermark) {
    plugins.push(watermarkPlugin({
      delay: 300,
      enabled: true,
      ...typeof pluginOptions.watermark === "object" ? pluginOptions.watermark : {}
    }));
  }
  if (pluginOptions.comment) {
    plugins.push(commentPlugin(pluginOptions.comment));
  }
  if (pluginOptions.sitemap !== false && hostname && isProd) {
    plugins.push(sitemapPlugin({ hostname }));
  }
  if (pluginOptions.seo !== false && hostname && isProd) {
    plugins.push(seoPlugin({ hostname }));
  }
  return plugins;
}

// src/node/setupPages.ts
import {
  ensureLeadingSlash as ensureLeadingSlash2,
  getRootLang,
  getRootLangPath as getRootLangPath3
} from "@vuepress/helper";
import { createPage } from "vuepress/core";
async function setupPage(app, localeOption) {
  const pageList = [];
  const locales = localeOption.locales || {};
  const rootPath = getRootLangPath3(app);
  const rootLang = getRootLang(app);
  const blog = localeOption.blog || {};
  const link = blog.link || "/blog/";
  const getTitle = (locale, key) => {
    const opt = PRESET_LOCALES[locale] || PRESET_LOCALES[rootPath] || {};
    return opt[key] || "";
  };
  for (const localePath of Object.keys(locales)) {
    const lang = app.siteData.locales?.[localePath]?.lang || rootLang;
    const locale = localePath === "/" ? rootPath : localePath;
    pageList.push(createPage(app, {
      path: withBase(link, localePath),
      frontmatter: { lang, _pageLayout: "blog", title: getTitle(locale, "blog") }
    }));
    if (blog.tags !== false) {
      pageList.push(createPage(app, {
        path: withBase(blog.tagsLink || `${link}/tags/`, localePath),
        frontmatter: { lang, _pageLayout: "blog-tags", title: getTitle(locale, "tag") }
      }));
    }
    if (blog.archives !== false) {
      pageList.push(createPage(app, {
        path: withBase(blog.archivesLink || `${link}/archives/`, localePath),
        frontmatter: { lang, _pageLayout: "blog-archives", title: getTitle(locale, "archive") }
      }));
    }
    if (blog.categories !== false) {
      pageList.push(createPage(app, {
        path: withBase(blog.categoriesLink || `${link}/categories/`, localePath),
        frontmatter: { lang, _pageLayout: "blog-categories", title: getTitle(locale, "category") }
      }));
    }
  }
  app.pages.push(...await Promise.all(pageList));
}
function extendsPageData(page, localeOptions) {
  page.data.filePathRelative = page.filePathRelative;
  page.routeMeta.title = page.frontmatter.title || page.title;
  if (page.frontmatter.icon) {
    page.routeMeta.icon = page.frontmatter.icon;
  }
  if (page.frontmatter.home) {
    page.frontmatter.pageLayout = "home";
    delete page.frontmatter.home;
  }
  if (page.frontmatter.article === false) {
    page.frontmatter.draft = true;
  }
  delete page.frontmatter.article;
  if (page.frontmatter.friends) {
    page.frontmatter.draft = true;
    page.data.type = "friends";
    page.permalink = page.permalink ?? "/friends/";
    page.frontmatter.pageLayout = "friends";
    delete page.frontmatter.friends;
  }
  const pageType = page.frontmatter._pageLayout;
  if (pageType) {
    page.frontmatter.draft = true;
    page.data.type = pageType;
    delete page.frontmatter._pageLayout;
  }
  if ("externalLink" in page.frontmatter) {
    page.frontmatter.externalLinkIcon = page.frontmatter.externalLink;
    delete page.frontmatter.externalLink;
  }
  autoCategory(page, localeOptions);
}
var uuid = 1e4;
var cache = {};
var RE_CATEGORY = /^(\d+)?\.?([\s\S]+)$/;
var LOCALE_RE;
function autoCategory(page, options) {
  const pagePath = page.filePathRelative;
  if (page.data.type || !pagePath)
    return;
  const notesLinks = resolveNotesLinkList(options);
  if (notesLinks.some((link) => page.path.startsWith(link)))
    return;
  LOCALE_RE ??= new RegExp(
    `^(${Object.keys(options.locales || {}).filter((l) => l !== "/").join("|")})`
  );
  const list = ensureLeadingSlash2(pagePath).replace(LOCALE_RE, "").replace(/^\//, "").split("/").slice(0, -1);
  const categoryList = list.map((category, index) => {
    const match = category.match(RE_CATEGORY) || [];
    if (!cache[match[2]] && !match[1]) {
      cache[match[2]] = uuid++;
    }
    return {
      id: hash(list.slice(0, index + 1).join("-")).slice(0, 6),
      sort: Number(match[1] || cache[match[2]]),
      name: match[2]
    };
  });
  page.data.categoryList = categoryList;
}

// src/node/loadConfig/findConfigPath.ts
import fs3, { constants, promises as fsp } from "node:fs";
import { resolve as resolve2 } from "node:path";
import process2 from "node:process";
import { colors } from "vuepress/utils";
var CONFIG_FILE_NAME = "plume.config";
var extensions = ["ts", "js", "mts", "cts", "mjs", "cjs"];
async function findConfigPath(app, configPath) {
  const cwd = process2.cwd();
  const source = app.dir.source(".vuepress");
  const paths = [];
  if (configPath) {
    const path9 = resolve2(cwd, configPath);
    if (existsSync(path9) && (await fsp.stat(path9)).isFile()) {
      return path9;
    }
  }
  extensions.forEach((ext) => {
    paths.push(resolve2(cwd, `./${CONFIG_FILE_NAME}.${ext}`));
    paths.push(resolve2(cwd, `${source}/${CONFIG_FILE_NAME}.${ext}`));
    paths.push(resolve2(cwd, `./.vuepress/${CONFIG_FILE_NAME}.${ext}`));
  });
  let current;
  for (const path9 of paths) {
    if (existsSync(path9) && (await fsp.stat(path9)).isFile()) {
      current = path9;
      break;
    }
  }
  if (configPath && current) {
    logger.warn(`Can not find config file: ${colors.gray(configPath)}
Use config file: ${colors.gray(current)}`);
  }
  return current;
}
function existsSync(fp) {
  try {
    fs3.accessSync(fp, constants.R_OK);
    return true;
  } catch {
    return false;
  }
}

// src/node/loadConfig/compiler.ts
import { promises as fsp2 } from "node:fs";
import path4 from "node:path";
import process3 from "node:process";
import { pathToFileURL } from "node:url";
import { build } from "esbuild";
import { importFileDefault } from "vuepress/utils";
async function compiler(configPath) {
  if (!configPath) {
    return { config: {}, dependencies: [] };
  }
  const dirnameVarName = "__vite_injected_original_dirname";
  const filenameVarName = "__vite_injected_original_filename";
  const importMetaUrlVarName = "__vite_injected_original_import_meta_url";
  const result = await build({
    absWorkingDir: process3.cwd(),
    entryPoints: [configPath],
    outfile: "out.js",
    write: false,
    target: ["node18"],
    platform: "node",
    bundle: true,
    format: "esm",
    sourcemap: "inline",
    metafile: true,
    define: {
      "__dirname": dirnameVarName,
      "__filename": filenameVarName,
      "import.meta.url": importMetaUrlVarName
    },
    plugins: [
      {
        name: "externalize-deps",
        setup(build2) {
          build2.onResolve({ filter: /.*/ }, ({ path: id }) => {
            if (id[0] !== "." && !path4.isAbsolute(id)) {
              return { external: true };
            }
            return null;
          });
        }
      },
      {
        name: "inject-file-scope-variables",
        setup(build2) {
          build2.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
            const contents = await fsp2.readFile(args.path, "utf8");
            const injectValues = `const ${dirnameVarName} = ${JSON.stringify(
              path4.dirname(args.path)
            )};const ${filenameVarName} = ${JSON.stringify(args.path)};const ${importMetaUrlVarName} = ${JSON.stringify(
              pathToFileURL(args.path).href
            )};`;
            return {
              loader: args.path.endsWith("ts") ? "ts" : "js",
              contents: injectValues + contents
            };
          });
        }
      }
    ]
  });
  const { text } = result.outputFiles[0];
  const tempFilePath = `${configPath}.${hash(text)}.mjs`;
  let config;
  try {
    await fsp2.writeFile(tempFilePath, text);
    config = await importFileDefault(tempFilePath);
  } finally {
    await fsp2.rm(tempFilePath);
  }
  return {
    config,
    dependencies: Object.keys(result.metafile?.inputs ?? {})
  };
}

// src/node/loadConfig/loader.ts
import { path as path5 } from "vuepress/utils";
import { watch } from "chokidar";
import { deepMerge } from "@pengzhanbo/utils";
var loader = null;
async function initConfigLoader(app, defaultConfig, { configFile, onChange } = {}) {
  const { encrypt, autoFrontmatter, ...localeOptions } = defaultConfig;
  loader = {
    configFile,
    dependencies: [],
    load: () => compiler(loader.configFile),
    loaded: false,
    changeEvents: [],
    whenLoaded: [],
    defaultConfig,
    resolvedConfig: {
      localeOptions: resolveLocaleOptions(app, localeOptions),
      encrypt,
      autoFrontmatter
    }
  };
  loader.configFile = await findConfigPath(app, configFile);
  if (onChange) {
    loader.changeEvents.push(onChange);
  }
  const { config, dependencies = [] } = await loader.load();
  loader.loaded = true;
  loader.dependencies = [...dependencies];
  updateResolvedConfig(app, config);
  runChangeEvents();
  loader.whenLoaded.forEach((fn) => fn(loader.resolvedConfig));
  loader.whenLoaded = [];
}
function watchConfigFile(app, watchers) {
  if (!loader || !loader.configFile)
    return;
  const watcher = watch(loader.configFile, {
    ignoreInitial: true,
    cwd: path5.join(path5.dirname(loader.configFile), "../")
  });
  addDependencies(watcher);
  watcher.on("change", async () => {
    if (loader) {
      loader.loaded = false;
      const { config, dependencies = [] } = await loader.load();
      loader.loaded = true;
      addDependencies(watcher, dependencies);
      updateResolvedConfig(app, config);
      runChangeEvents();
    }
  });
  watcher.on("unlink", async () => {
    updateResolvedConfig(app);
    runChangeEvents();
  });
  watchers.push(watcher);
}
async function onConfigChange(onChange) {
  if (loader && !loader.changeEvents.includes(onChange)) {
    loader.changeEvents.push(onChange);
    if (loader.loaded) {
      onChange(loader.resolvedConfig);
    }
  }
}
function waitForConfigLoaded() {
  return new Promise((resolve3) => {
    if (loader?.loaded) {
      resolve3(loader.resolvedConfig);
    } else {
      loader?.whenLoaded.push(resolve3);
    }
  });
}
function getResolvedThemeConfig() {
  return loader.resolvedConfig;
}
function updateResolvedConfig(app, userConfig = {}) {
  if (loader) {
    const { encrypt, autoFrontmatter, ...localeOptions } = deepMerge({}, loader.defaultConfig, userConfig);
    loader.resolvedConfig = {
      localeOptions: resolveLocaleOptions(app, localeOptions),
      encrypt,
      autoFrontmatter
    };
  }
}
function runChangeEvents() {
  if (loader) {
    loader.changeEvents.forEach((fn) => fn(loader.resolvedConfig));
  }
}
function addDependencies(watcher, dependencies) {
  if (!loader)
    return;
  if (dependencies?.length) {
    const deps = dependencies.filter((dep) => !loader.dependencies.includes(dep) && dep[0] === ".");
    loader.dependencies.push(...deps);
    watcher.add(deps);
  } else {
    watcher.add(loader.dependencies);
  }
}

// src/node/autoFrontmatter/generator.ts
import { fs as fs5, hash as hash2 } from "vuepress/utils";
import chokidar from "chokidar";
import { createFilter } from "create-filter";
import grayMatter from "gray-matter";
import jsonToYaml from "json2yaml";
import { isArray, isEmptyObject, promiseParallel, toArray } from "@pengzhanbo/utils";

// src/node/autoFrontmatter/readFile.ts
import { fs as fs4, path as path6 } from "vuepress/utils";
import fg from "fast-glob";
async function readMarkdownList(sourceDir, filter) {
  const files = await fg(["**/*.md"], {
    cwd: sourceDir,
    ignore: ["node_modules", ".vuepress"]
  });
  return await Promise.all(
    files.filter(filter).map((file) => readMarkdown(sourceDir, file))
  );
}
async function readMarkdown(sourceDir, relativePath) {
  const filepath = path6.join(sourceDir, relativePath);
  const stats = await fs4.promises.stat(filepath);
  return {
    filepath,
    relativePath,
    content: await fs4.promises.readFile(filepath, "utf-8"),
    createTime: getFileCreateTime(stats),
    stats
  };
}
function getFileCreateTime(stats) {
  return stats.birthtime.getFullYear() !== 1970 ? stats.birthtime : stats.atime;
}

// src/node/autoFrontmatter/resolveOptions.ts
import { path as path7 } from "vuepress/utils";
import { removeLeadingSlash, resolveLocalePath } from "vuepress/shared";
import { ensureLeadingSlash as ensureLeadingSlash3 } from "@vuepress/helper";
import { format } from "date-fns";
import { uniq as uniq2 } from "@pengzhanbo/utils";
function resolveOptions(localeOptions, options) {
  const pkg = getPackage();
  const { locales = {}, article: articlePrefix = "/article/" } = localeOptions;
  const resolveLocale = (relativeFilepath) => {
    const file = ensureLeadingSlash3(relativeFilepath);
    return resolveLocalePath(localeOptions.locales, file);
  };
  const resolveOptions2 = (relativeFilepath) => {
    const locale = resolveLocale(relativeFilepath);
    return locales[locale] || localeOptions;
  };
  const notesList = resolveNotesOptions(localeOptions);
  const localesNotesDirs = notesList.flatMap(({ notes, dir }) => {
    dir = removeLeadingSlash(dir || "");
    return notes.map((note) => normalizePath(`${dir}/${note.dir || ""}/`));
  }).filter(Boolean);
  const baseFrontmatter = {};
  if (options.author !== false) {
    baseFrontmatter.author = (author, { relativePath }, data) => {
      if (author)
        return author;
      if (data.friends || data.pageLayout === "friends")
        return;
      const profile = resolveOptions2(relativePath).profile ?? resolveOptions2(relativePath).avatar;
      return profile?.name || pkg.author || "";
    };
  }
  if (options.createTime !== false) {
    baseFrontmatter.createTime = (formatTime, { createTime }, data) => {
      if (formatTime)
        return formatTime;
      if (data.friends || data.pageLayout === "friends")
        return;
      return format(new Date(createTime), "yyyy/MM/dd HH:mm:ss");
    };
  }
  const notesByLocale = (locale) => {
    const notes = localeOptions.locales?.[locale]?.notes;
    if (notes === false)
      return void 0;
    return notes;
  };
  const findNote = (relativeFilepath) => {
    const locale = resolveLocale(relativeFilepath);
    const filepath = ensureLeadingSlash3(relativeFilepath);
    const notes = notesByLocale(locale);
    if (!notes)
      return void 0;
    const notesList2 = notes?.notes || [];
    const notesDir = notes?.dir || "";
    return notesList2.find(
      (note) => filepath.startsWith(normalizePath(`${notesDir}/${note.dir}`))
    );
  };
  return {
    include: options?.include ?? ["**/*.md"],
    exclude: uniq2([".vuepress/**/*", "node_modules", ...options?.exclude ?? []]),
    frontmatter: [
      localesNotesDirs.length ? {
        // note 首页链接
        include: localesNotesDirs.map((dir) => pathJoin(dir, "/{readme,README,index}.md")),
        frontmatter: {
          ...options.title !== false ? {
            title(title, { relativePath }) {
              if (title)
                return title;
              const note = findNote(relativePath);
              if (note?.text)
                return note.text;
              return getCurrentDirname("", relativePath) || "";
            }
          } : void 0,
          ...baseFrontmatter,
          ...options.permalink !== false ? {
            permalink(permalink, { relativePath }, data) {
              if (permalink)
                return permalink;
              if (data.friends)
                return;
              const locale = resolveLocale(relativePath);
              const prefix = notesByLocale(locale)?.link || "";
              const note = findNote(relativePath);
              return pathJoin(
                locale,
                prefix,
                note?.link || getCurrentDirname(note?.dir, relativePath),
                "/"
              );
            }
          } : void 0
        }
      } : "",
      localesNotesDirs.length ? {
        include: localesNotesDirs.map((dir) => `${dir}**/**.md`),
        frontmatter: {
          ...options.title !== false ? {
            title(title, { relativePath }) {
              if (title)
                return title;
              const note = findNote(relativePath);
              let basename = path7.basename(relativePath, ".md");
              if (note?.sidebar === "auto")
                basename = basename.replace(/^\d+\./, "");
              return basename;
            }
          } : void 0,
          ...baseFrontmatter,
          ...options.permalink !== false ? {
            permalink(permalink, { relativePath }, data) {
              if (permalink)
                return permalink;
              if (data.friends)
                return;
              const locale = resolveLocale(relativePath);
              const notes = notesByLocale(locale);
              const note = findNote(relativePath);
              const prefix = notes?.link || "";
              const args = [
                locale,
                prefix,
                note?.link || ""
              ];
              const sidebar = note?.sidebar;
              if (note && sidebar && sidebar !== "auto") {
                const res = resolveLinkBySidebar(sidebar, pathJoin(notes?.dir || "", note.dir || ""));
                const file = ensureLeadingSlash3(relativePath);
                if (res[file]) {
                  args.push(res[file]);
                } else if (res[path7.dirname(file)]) {
                  args.push(res[path7.dirname(file)]);
                }
              }
              return pathJoin(...args, nanoid(), "/");
            }
          } : void 0
        }
      } : "",
      {
        include: "**/{readme,README,index}.md",
        frontmatter: {}
      },
      {
        include: localeOptions.blog?.include ?? ["**/*.md"],
        frontmatter: {
          ...options.title !== false ? {
            title(title, { relativePath }) {
              if (title)
                return title;
              const basename = path7.basename(relativePath || "", ".md");
              return basename;
            }
          } : void 0,
          ...baseFrontmatter,
          ...options.permalink !== false ? {
            permalink(permalink, { relativePath }) {
              if (permalink)
                return permalink;
              const locale = resolveLocale(relativePath);
              const prefix = withBase(articlePrefix, locale);
              return normalizePath(`${prefix}/${nanoid()}/`);
            }
          } : void 0
        }
      },
      {
        include: "*",
        frontmatter: {
          ...options.title !== false ? {
            title(title, { relativePath }) {
              if (title)
                return title;
              const basename = path7.basename(relativePath || "", ".md");
              return basename;
            }
          } : void 0,
          ...baseFrontmatter,
          ...options.permalink !== false ? {
            permalink(permalink, { relativePath }) {
              if (permalink)
                return permalink;
              return ensureLeadingSlash3(normalizePath(relativePath.replace(/\.md$/, "/")));
            }
          } : void 0
        }
      }
    ].filter(Boolean)
  };
}
function resolveLinkBySidebar(sidebar, _prefix) {
  const res = {};
  if (sidebar === "auto") {
    return res;
  }
  for (const item of sidebar) {
    if (typeof item !== "string") {
      const { prefix, dir = "", link = "/", items, text = "" } = item;
      getSidebarLink(items, link, text, pathJoin(_prefix, prefix || dir), res);
    }
  }
  return res;
}
function getSidebarLink(items, link, text, dir = "", res = {}) {
  if (items === "auto")
    return;
  if (!items) {
    res[pathJoin(dir, `${text}.md`)] = link;
    return;
  }
  for (const item of items) {
    if (typeof item === "string") {
      if (!link)
        continue;
      if (item) {
        res[pathJoin(dir, `${item}.md`)] = link;
      } else {
        res[pathJoin(dir, "README.md")] = link;
        res[pathJoin(dir, "index.md")] = link;
        res[pathJoin(dir, "readme.md")] = link;
      }
      res[dir] = link;
    } else {
      const { prefix, dir: subDir = "", link: subLink = "/", items: subItems, text: subText = "" } = item;
      getSidebarLink(subItems, pathJoin(link, subLink), subText, pathJoin(prefix || dir, subDir), res);
    }
  }
}

// src/node/autoFrontmatter/generator.ts
var generate = null;
var generated = false;
var whenGenerated = [];
function initAutoFrontmatter(localeOptions, autoFrontmatter = {}) {
  const { include, exclude, frontmatter = {} } = resolveOptions(localeOptions, autoFrontmatter);
  const globFilter = createFilter(include, exclude, { resolve: false });
  const userConfig = isArray(frontmatter) ? frontmatter : [{ include: "*", frontmatter }];
  const globalConfig = userConfig.find(({ include: include2 }) => include2 === "*")?.frontmatter || {};
  const rules = userConfig.filter(({ include: include2 }) => include2 !== "*").map(({ include: include2, frontmatter: frontmatter2 }) => {
    return {
      include: include2,
      filter: createFilter(toArray(include2), void 0, { resolve: false }),
      frontmatter: frontmatter2
    };
  });
  generate = {
    globFilter,
    global: globalConfig,
    rules
  };
}
async function generateAutoFrontmatter(app) {
  if (!generate)
    return;
  generated = false;
  const markdownList = await readMarkdownList(app.dir.source(), generate.globFilter);
  await promiseParallel(
    markdownList.map((file) => () => generator(file)),
    64
  );
  generated = true;
  whenGenerated.forEach((resolve3) => resolve3());
  whenGenerated.length = 0;
}
async function watchAutoFrontmatter(app, watchers, enable) {
  if (!generate)
    return;
  const watcher = chokidar.watch("**/*.md", {
    cwd: app.dir.source(),
    ignoreInitial: true,
    ignored: /(node_modules|\.vuepress)\//
  });
  watcher.on("add", async (relativePath) => {
    const enabled = enable ? enable() : true;
    if (!generate.globFilter(relativePath) || !enabled)
      return;
    const file = await readMarkdown(app.dir.source(), relativePath);
    await generator(file);
  });
  watchers.push(watcher);
}
async function generator(file) {
  if (!generate)
    return;
  const { filepath, relativePath } = file;
  const current = generate.rules.find(({ filter }) => filter(relativePath));
  const formatter = current?.frontmatter || generate.global;
  const { data, content } = grayMatter(file.content);
  const beforeHash = hash2(data);
  for (const key in formatter) {
    const value = await formatter[key](data[key], file, data);
    data[key] = value ?? data[key];
  }
  if (beforeHash === hash2(data))
    return;
  try {
    const yaml = isEmptyObject(data) ? "" : jsonToYaml.stringify(data).replace(/\n\s{2}/g, "\n").replace(/"/g, "").replace(/\s+\n/g, "\n");
    const newContent = yaml ? `${yaml}---
${content}` : content;
    await fs5.promises.writeFile(filepath, newContent, "utf-8");
  } catch (e) {
    console.error(e);
  }
}
function waitForAutoFrontmatter() {
  return new Promise((resolve3) => {
    if (generate && !generated)
      whenGenerated.push(resolve3);
    else
      resolve3();
  });
}

// src/node/prepare/index.ts
import { watch as watch2 } from "chokidar";

// src/node/prepare/prepareArticleTagColor.ts
import { toArray as toArray2 } from "@pengzhanbo/utils";
var PRESET = [
  ["#6aa1b7", "#5086a1", "rgba(131, 208, 218, 0.314)"],
  ["#299764", "#18794e", "rgba(16, 185, 129, 0.14)"],
  ["#946300", "#915930", "rgba(234, 179, 8, 0.14)"],
  ["#d5393e", "#b8272c", "rgba(244, 63, 94, 0.14)"],
  ["#7e4cc9", "#6f42c1", "rgba(159, 122, 234, 0.14)"],
  ["#3a5ccc", "#3451b2", "rgba(100, 108, 255, 0.14)"],
  ["#fab10f", "#f39c12", "rgba(255, 213, 0, 0.14)"],
  ["#cc6699", "#be3f7f", "rgba(161, 54, 107, 0.14)"],
  ["#55aaee", "#2391e9", "rgba(21, 123, 206, 0.1333)"],
  ["#9933cc", "#aa56d5", "rgba(179, 102, 217, 0.2)"],
  ["#cc3366", "#d55680", "rgba(217, 102, 140, 0.2)"],
  ["#cc9933", "#be7f3f", "rgba(161, 107, 54, 0.2)"],
  ["#9966cc", "#7171b8", "rgba(83, 83, 167, 0.14)"],
  ["#66cccc", "#3fbebe", "rgba(54, 161, 161, 0.14)"],
  ["#3366cc", "#5680d5", "rgba(102, 140, 217, 0.14)"],
  ["#339999", "#41c0c0", "rgba(83, 198, 198, 0.2)"],
  ["#a6623b", "#c17950", "rgba(199, 134, 97, 0.2411)"],
  ["#8ecaef", "#55afe7", "rgba(42, 155, 225, 0.147)"]
];
var cache2 = {};
async function prepareArticleTagColors(app) {
  const { js, css } = genCode(app);
  await writeTemp(app, "internal/articleTagColors.css", css);
  await writeTemp(app, "internal/articleTagColors.js", js);
}
function genCode(app) {
  const articleTagColors = {};
  const tagList = /* @__PURE__ */ new Set();
  app.pages.forEach((page) => {
    const { frontmatter: { tags } } = page;
    if (tags) {
      toArray2(tags).forEach((tag) => {
        if (tag) {
          tagList.add(tag);
        }
      });
    }
  });
  tagList.forEach((tag) => {
    const code = getTagCode(tag);
    if (!cache2[code]) {
      cache2[code] = nanoid(4);
    }
    if (!articleTagColors[tag]) {
      articleTagColors[tag] = cache2[code];
    }
  });
  const js = resolveContent(app, {
    name: "articleTagColors",
    content: articleTagColors,
    before: `import './articleTagColors.css'`
  });
  const css = genCSS();
  return { js, css };
}
function getTagCode(tag) {
  tag = tag.toLowerCase();
  let code = 0;
  for (let i = 0; i < tag.length; i++) {
    code += tag.charCodeAt(i);
  }
  return code % PRESET.length;
}
function genCSS() {
  let css = "";
  for (const [code, className] of Object.entries(cache2)) {
    const index = Number(code);
    const [color, hoverColor, backgroundColor] = PRESET[index];
    css += `.vp-tag-${className} {
  --vp-tag-color: ${color};
  --vp-tag-hover-color: ${hoverColor};
  --vp-tag-bg: ${backgroundColor};
}
`;
  }
  return css;
}

// src/node/prepare/prepareBlogData.ts
import { createFilter as createFilter2 } from "create-filter";
import { removeLeadingSlash as removeLeadingSlash2 } from "@vuepress/helper";

// src/node/prepare/prepareEncrypt.ts
import { genSaltSync, hashSync } from "bcrypt-ts";
import { isNumber, isString, random, toArray as toArray3 } from "@pengzhanbo/utils";
var isStringLike = (value) => isString(value) || isNumber(value);
var separator = ":";
var contentHash2 = "";
async function prepareEncrypt(app, encrypt) {
  const currentHash = encrypt ? hash(JSON.stringify(encrypt)) : "";
  if (!contentHash2 || contentHash2 !== currentHash) {
    contentHash2 = currentHash;
    const content = resolveContent(app, {
      name: "encrypt",
      content: resolveEncrypt(encrypt)
    });
    await writeTemp(app, "internal/encrypt.js", content);
  }
}
function resolveEncrypt(encrypt) {
  const salt = () => genSaltSync(random(8, 16));
  const admin = encrypt?.admin ? toArray3(encrypt.admin).filter(isStringLike).map((item) => hashSync(String(item), salt())).join(separator) : "";
  const rules = {};
  const keys = Object.keys(encrypt?.rules ?? {});
  if (encrypt?.rules) {
    Object.keys(encrypt.rules).forEach((key) => {
      const index = keys.indexOf(key);
      rules[String(index)] = toArray3(encrypt.rules[key]).filter(isStringLike).map((item) => hashSync(String(item), salt())).join(separator);
    });
  }
  return [encrypt?.global ?? false, separator, admin, keys, rules];
}
function isEncryptPage(page, encrypt) {
  if (!encrypt)
    return false;
  const rules = encrypt.rules ?? {};
  return Object.keys(rules).some((match) => {
    const relativePath = page.data.filePathRelative || "";
    if (match[0] === "^") {
      const regex = new RegExp(match);
      return regex.test(page.path) || relativePath && regex.test(relativePath);
    }
    if (match.endsWith(".md"))
      return relativePath && relativePath.endsWith(match);
    return page.path.startsWith(match) || relativePath.startsWith(match);
  });
}

// src/node/prepare/prepareBlogData.ts
var HEADING_RE = /<h(\d)[^>]*>.*?<\/h\1>/gi;
var EXCERPT_SPLIT = "<!-- more -->";
function getTimestamp(time) {
  return new Date(time).getTime();
}
async function preparedBlogData(app, localeOptions, encrypt) {
  const start = performance.now();
  const blog = localeOptions.blog || {};
  const notesList = resolveNotesOptions(localeOptions);
  const notesDirList = notesList.map((notes) => removeLeadingSlash2(normalizePath(`${notes.dir}/**`))).filter(Boolean);
  const filter = createFilter2(
    blog.include ?? ["**/*.md"],
    [
      "**/{README,readme,index}.md",
      ".vuepress/",
      "node_modules/",
      ...blog.exclude ?? [],
      ...notesDirList
    ].filter(Boolean),
    { resolve: false }
  );
  const pages = app.pages.filter(
    (page) => page.filePathRelative && filter(page.filePathRelative) && page.frontmatter.draft !== true
  ).sort(
    (prev, next) => getTimestamp(prev.frontmatter.createTime || prev.date) < getTimestamp(next.frontmatter.createTime || next.date) ? 1 : -1
  );
  const blogData = pages.map((page) => {
    const tags = page.frontmatter.tags;
    const data = {
      path: page.path,
      title: page.title,
      categoryList: page.data.categoryList,
      tags,
      sticky: page.frontmatter.sticky,
      createTime: page.data.frontmatter.createTime || page.date?.replaceAll("-", "/") || "",
      lang: page.lang,
      excerpt: ""
    };
    if (isEncryptPage(page, encrypt)) {
      data.encrypt = true;
    }
    if (page.contentRendered.includes(EXCERPT_SPLIT)) {
      const contents = page.contentRendered.split(EXCERPT_SPLIT);
      let excerpt = contents[0];
      excerpt = excerpt.replace(HEADING_RE, "");
      data.excerpt = excerpt;
    }
    return data;
  });
  const content = resolveContent(app, { name: "blogPostData", content: blogData });
  await writeTemp(app, "internal/blogData.js", content);
  if (app.env.isDebug)
    logger.info(`prepare blog data time spent: ${(performance.now() - start).toFixed(2)}ms`);
}

// src/node/prepare/prepareSidebar.ts
import {
  entries as entries5,
  isArray as isArray2,
  isPlainObject as isPlainObject2,
  removeLeadingSlash as removeLeadingSlash3
} from "@vuepress/helper";
async function prepareSidebar(app, localeOptions) {
  const sidebar = getAllSidebar(localeOptions);
  sidebar.__auto__ = getSidebarData(app, sidebar);
  await writeTemp(app, "internal/sidebar.js", resolveContent(app, { name: "sidebar", content: sidebar }));
}
function getSidebarData(app, locales) {
  const autoDirList = [];
  const resolved = {};
  entries5(locales).forEach(([localePath, sidebar]) => {
    if (!sidebar)
      return;
    if (isArray2(sidebar)) {
      autoDirList.push(...findAutoDirList(sidebar));
    } else if (isPlainObject2(sidebar)) {
      entries5(sidebar).forEach(([dirname, config]) => {
        const prefix = normalizeLink(localePath, dirname);
        if (config === "auto") {
          autoDirList.push(prefix);
        } else if (isArray2(config)) {
          autoDirList.push(...findAutoDirList(config, prefix));
        } else if (config.items === "auto") {
          autoDirList.push(normalizeLink(prefix, config.prefix));
        } else {
          autoDirList.push(
            ...findAutoDirList(
              config.items || [],
              normalizeLink(prefix, config.prefix)
            )
          );
        }
      });
    } else if (sidebar === "auto") {
      autoDirList.push(localePath);
    }
  });
  autoDirList.forEach((localePath) => {
    resolved[localePath] = getAutoDirSidebar(app, localePath);
  });
  return resolved;
}
var MD_RE = /\.md$/;
var NUMBER_RE = /^\d+\./;
function resolveTitle(dirname) {
  return dirname.replace(MD_RE, "").replace(NUMBER_RE, "");
}
function getAutoDirSidebar(app, localePath) {
  const locale = removeLeadingSlash3(localePath);
  let pages = app.pages.filter((page) => page.data.filePathRelative?.startsWith(locale)).map((page) => {
    return { ...page, splitPath: page.data.filePathRelative?.split("/") || [] };
  });
  const maxIndex = Math.max(...pages.map((page) => page.splitPath.length));
  let nowIndex = 0;
  while (nowIndex < maxIndex) {
    pages = pages.sort((prev, next) => {
      const pi = prev.splitPath?.[nowIndex]?.match(/(\d+)\.(?=[^/]+$)/)?.[1];
      const ni = next.splitPath?.[nowIndex]?.match(/(\d+)\.(?=[^/]+$)/)?.[1];
      if (!pi || !ni)
        return 0;
      return Number.parseFloat(pi) < Number.parseFloat(ni) ? -1 : 1;
    });
    nowIndex++;
  }
  const RE_INDEX = ["index.md", "README.md", "readme.md"];
  const result = [];
  for (const page of pages) {
    const { data, title, path: path9, frontmatter } = page;
    const paths = (data.filePathRelative || "").slice(localePath.replace(/^\/|\/$/g, "").length + 1).split("/");
    let index = 0;
    let dir;
    let items = result;
    let parent;
    while (dir = paths[index]) {
      const text = resolveTitle(dir);
      const isHome = RE_INDEX.includes(dir);
      let current = items.find((item) => item.text === text);
      if (!current) {
        current = { text, link: void 0, items: [] };
        if (!isHome) {
          items.push(current);
        } else if (!parent) {
          items.unshift(current);
        }
      }
      if (dir.endsWith(".md")) {
        if (isHome && parent) {
          parent.link = path9;
        } else {
          current.link = path9;
          current.text = title;
        }
      }
      if (frontmatter.icon) {
        current.icon = frontmatter.icon;
      }
      if (parent?.items?.length) {
        parent.collapsed = false;
      }
      parent = current;
      items = current.items;
      index++;
    }
  }
  return result;
}
function findAutoDirList(sidebar, prefix = "") {
  const list = [];
  if (!sidebar.length)
    return list;
  sidebar.forEach((item) => {
    if (isPlainObject2(item)) {
      const nextPrefix = normalizeLink(prefix, item.prefix || item.dir);
      if (item.items === "auto") {
        list.push(nextPrefix);
      } else if (item.items?.length) {
        list.push(...findAutoDirList(item.items, nextPrefix));
      }
    }
  });
  return list;
}
function getAllSidebar(localeOptions) {
  const locales = {};
  for (const [locale, opt] of entries5(localeOptions.locales || {})) {
    const notes = locale === "/" ? opt.notes || localeOptions.notes : opt.notes;
    const sidebar = locale === "/" ? opt.sidebar || localeOptions.sidebar : opt.sidebar;
    locales[locale] = { ...sidebar };
    if (notes && notes.notes?.length) {
      const prefix = notes.link || "";
      for (const note of notes.notes) {
        if (note.sidebar) {
          locales[locale][normalizeLink(prefix, note.link || "/")] = {
            items: note.sidebar,
            prefix: normalizeLink(notes.dir, note.dir)
          };
        }
      }
    }
  }
  return locales;
}

// src/node/prepare/index.ts
async function prepareData(app) {
  const { localeOptions, encrypt } = getResolvedThemeConfig();
  await Promise.all([
    prepareArticleTagColors(app),
    preparedBlogData(app, localeOptions, encrypt),
    prepareSidebar(app, localeOptions),
    prepareEncrypt(app, encrypt)
  ]);
}
function watchPrepare(app, watchers) {
  const pagesWatcher = watch2("pages/**", {
    cwd: app.dir.temp(),
    ignoreInitial: true
  });
  watchers.push(pagesWatcher);
  pagesWatcher.on("change", () => prepareData(app));
  pagesWatcher.on("add", () => prepareData(app));
  pagesWatcher.on("unlink", () => prepareData(app));
}

// src/node/prepare/prepareThemeData.ts
async function prepareThemeData(app, localeOptions) {
  const resolvedThemeData = resolveThemeData(app, localeOptions);
  const content = resolveContent(app, { name: "themeData", content: resolvedThemeData });
  await writeTemp(app, "internal/themePlumeData.js", content);
}

// src/node/extendsMarkdown.ts
import process4 from "node:process";
import { fs as fs6, path as path8 } from "vuepress/utils";
var CACHE_DIR = "markdown/rendered";
var META_FILE = "_metadata.json";
async function extendsMarkdown(md, app) {
  if (app.env.isBuild && !fs6.existsSync(app.dir.cache(CACHE_DIR))) {
    return;
  }
  const basename = app.dir.cache(CACHE_DIR);
  await fs6.ensureDir(basename);
  const speed = checkIOSpeed(basename);
  const metaFilepath = `${basename}/${META_FILE}`;
  const metadata = await readFile(metaFilepath) || {};
  let timer = null;
  const update = (filepath, data) => {
    writeFile(`${basename}/${filepath}`, data);
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(async () => writeFile(metaFilepath, metadata), 200);
  };
  const rawRender = md.render;
  md.render = (input, env) => {
    const filepath = env.filePathRelative;
    if (!filepath) {
      return rawRender(input, env);
    }
    const key = hash(input);
    const filename = normalizeFilename(filepath);
    if (metadata[filepath] === key) {
      const cached = readFileSync(`${basename}/${filename}`);
      if (cached) {
        Object.assign(env, cached.env);
        return cached.content;
      } else {
        metadata[filepath] = "";
      }
    }
    const start = performance.now();
    const content = rawRender(input, env);
    if (performance.now() - start > speed) {
      metadata[filepath] = key;
      update(filename, { content, env });
    }
    return content;
  };
}
function normalizeFilename(filename) {
  return hash(filename).slice(0, 10);
}
async function readFile(filepath) {
  try {
    const content = await fs6.readFile(filepath, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
function readFileSync(filepath) {
  try {
    const content = fs6.readFileSync(filepath, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
async function writeFile(filepath, data) {
  return await fs6.writeFile(filepath, JSON.stringify(data), "utf-8");
}
function checkIOSpeed(cwd = process4.cwd()) {
  try {
    const tmp = path8.join(cwd, "tmp");
    fs6.writeFileSync(tmp, "{}", "utf-8");
    const start = performance.now();
    readFileSync(tmp);
    const end = performance.now();
    fs6.unlinkSync(tmp);
    return end - start;
  } catch {
    return 0.15;
  }
}

// src/node/theme.ts
function plumeTheme(options = {}) {
  const {
    localeOptions,
    pluginOptions,
    hostname,
    configFile
  } = resolveThemeOptions(options);
  return (app) => {
    initConfigLoader(app, localeOptions, {
      configFile,
      onChange: ({ localeOptions: localeOptions2, autoFrontmatter }) => {
        autoFrontmatter ??= pluginOptions.frontmatter;
        if (autoFrontmatter !== false) {
          initAutoFrontmatter(localeOptions2, autoFrontmatter);
        }
      }
    });
    waitForConfigLoaded().then(({ autoFrontmatter }) => {
      autoFrontmatter ??= pluginOptions.frontmatter;
      if (autoFrontmatter !== false) {
        generateAutoFrontmatter(app);
      }
    });
    return {
      name: THEME_NAME,
      define: resolveProvideData(app, pluginOptions),
      templateBuild: templates("build.html"),
      clientConfigFile: resolve("client/config.js"),
      alias: resolveAlias(),
      plugins: getPlugins({ app, pluginOptions, hostname }),
      onInitialized: async (app2) => {
        const { localeOptions: localeOptions2 } = await waitForConfigLoaded();
        await setupPage(app2, localeOptions2);
      },
      onPrepared: async (app2) => {
        onConfigChange(({ localeOptions: localeOptions2 }) => {
          prepareThemeData(app2, localeOptions2);
          prepareData(app2);
        });
        await waitForConfigLoaded();
      },
      onWatched: (app2, watchers) => {
        watchConfigFile(app2, watchers);
        watchPrepare(app2, watchers);
        watchAutoFrontmatter(app2, watchers, () => {
          const autoFrontmatter = getResolvedThemeConfig().autoFrontmatter ?? pluginOptions.frontmatter;
          return autoFrontmatter !== false;
        });
      },
      extendsPage: async (page) => {
        const { localeOptions: localeOptions2 } = await waitForConfigLoaded();
        await waitForAutoFrontmatter();
        extendsPageData(page, localeOptions2);
        resolvePageHead(page, localeOptions2);
      },
      extendsMarkdown,
      extendsBundlerOptions,
      templateBuildRenderer
    };
  };
}

// src/node/defineConfig.ts
function definePlumeNotesConfig(notes) {
  return notes;
}
function definePlumeNotesItemConfig(item) {
  return item;
}
function defineNavbarConfig(navbar) {
  return navbar;
}
function defineNavbar(navbar) {
  return navbar;
}
function defineThemeConfig(config) {
  return config;
}

// src/node/index.ts
export * from "../shared/index.js";
var node_default = plumeTheme;
export {
  node_default as default,
  defineNavbar,
  defineNavbarConfig,
  definePlumeNotesConfig,
  definePlumeNotesItemConfig,
  defineThemeConfig,
  plumeTheme
};

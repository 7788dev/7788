// src/client/utils/shared.ts
var EXTERNAL_URL_RE = /^[a-z]+:/i;
var PATHNAME_PROTOCOL_RE = /^pathname:\/\//;
var HASH_RE = /#.*$/;
var EXT_RE = /(index|README)?\.(md|html)$/;
var inBrowser = typeof document !== "undefined";
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function isActive(currentPath, matchPath, asRegex = false) {
  if (matchPath === void 0)
    return false;
  currentPath = normalize(`/${currentPath.replace(/^\//, "")}`);
  if (asRegex)
    return new RegExp(matchPath).test(currentPath);
  if (normalize(matchPath) !== currentPath)
    return false;
  const hashMatch = matchPath.match(HASH_RE);
  if (hashMatch)
    return (inBrowser ? location.hash : "") === hashMatch[0];
  return true;
}
function normalize(path) {
  return decodeURI(path).replace(HASH_RE, "").replace(EXT_RE, "");
}
function throttleAndDebounce(fn, delay) {
  let timeoutId;
  let called = false;
  return () => {
    if (timeoutId)
      clearTimeout(timeoutId);
    if (!called) {
      fn();
      called = true;
      setTimeout(() => {
        called = false;
      }, delay);
    } else {
      timeoutId = setTimeout(fn, delay);
    }
  };
}

// src/client/utils/animate.ts
function tween(t, b, c, d) {
  return c * (t /= d) * t * t + b;
}
function linear(t, b, c, d) {
  return c * t / d + b;
}

// src/client/utils/dom.ts
function getCssValue(el, property) {
  const val = el?.ownerDocument?.defaultView?.getComputedStyle(el, null)?.[property];
  const num = Number.parseInt(val, 10);
  return Number.isNaN(num) ? 0 : num;
}
function getScrollTop(target = document) {
  if (target === document || !target) {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  } else {
    return target.scrollTop;
  }
}
function setScrollTop(target = document, scrollTop = 0) {
  if (typeof target === "number") {
    scrollTop = target;
    target = document;
    document.documentElement.scrollTop = scrollTop;
    document.body.scrollTop = scrollTop;
  } else {
    if (target === document) {
      document.body.scrollTop = scrollTop || 0;
      document.documentElement.scrollTop = scrollTop || 0;
    } else {
      ;
      target.scrollTop = scrollTop || 0;
    }
  }
}
function scrollTo(target, top, time = 300) {
  if (target !== document) {
    const currentTop = getScrollTop(target);
    const step = Math.ceil(time / 16);
    let currentStep = 0;
    const change = top - currentTop;
    const timer = setInterval(() => {
      currentStep++;
      if (currentStep >= step && timer)
        clearInterval(timer);
      setScrollTop(target, tween(currentStep, currentTop, change, step));
    }, 1e3 / 60);
  } else {
    window.scrollTo({ top, behavior: "smooth" });
  }
}

// src/client/utils/resolveEditLink.ts
import {
  isLinkHttp as isLinkHttp2,
  removeEndingSlash,
  removeLeadingSlash
} from "vuepress/shared";

// src/client/utils/resolveRepoType.ts
import { isLinkHttp } from "vuepress/shared";
function resolveRepoType(repo) {
  if (!isLinkHttp(repo) || /github\.com/.test(repo))
    return "GitHub";
  if (/bitbucket\.org/.test(repo))
    return "Bitbucket";
  if (/gitlab\.com/.test(repo))
    return "GitLab";
  if (/gitee\.com/.test(repo))
    return "Gitee";
  return null;
}

// src/client/utils/resolveEditLink.ts
var editLinkPatterns = {
  GitHub: ":repo/edit/:branch/:path",
  GitLab: ":repo/-/edit/:branch/:path",
  Gitee: ":repo/edit/:branch/:path",
  Bitbucket: ":repo/src/:branch/:path?mode=edit&spa=0&at=:branch&fileviewer=file-view-default"
};
function resolveEditLinkPatterns({
  docsRepo,
  editLinkPattern
}) {
  if (editLinkPattern)
    return editLinkPattern;
  const repoType = resolveRepoType(docsRepo);
  if (repoType !== null)
    return editLinkPatterns[repoType];
  return null;
}
function resolveEditLink({
  docsRepo,
  docsBranch,
  docsDir,
  filePathRelative,
  editLinkPattern
}) {
  if (!filePathRelative)
    return null;
  const pattern = resolveEditLinkPatterns({ docsRepo, editLinkPattern });
  if (!pattern)
    return null;
  return pattern.replace(
    /:repo/,
    isLinkHttp2(docsRepo) ? docsRepo : `https://github.com/${docsRepo}`
  ).replace(/:branch/, docsBranch).replace(
    /:path/,
    removeLeadingSlash(`${removeEndingSlash(docsDir)}/${filePathRelative}`)
  );
}

// src/client/utils/resolveNavLink.ts
import { resolveRoute } from "vuepress/client";
import {
  ensureEndingSlash,
  ensureLeadingSlash,
  isLinkAbsolute,
  isLinkWithProtocol
} from "@vuepress/helper/client";
function resolveNavLink(link) {
  const { notFound, meta, path } = resolveRoute(link);
  return notFound ? { text: path, link: path } : {
    text: meta.title || path,
    link: path,
    icon: meta.icon
  };
}
function normalizeLink(base = "", link = "") {
  return isLinkAbsolute(link) || isLinkWithProtocol(link) ? link : ensureLeadingSlash(`${base}/${link}`.replace(/\/+/g, "/"));
}
function normalizePrefix(base, link = "") {
  return ensureEndingSlash(normalizeLink(base, link));
}
export {
  EXTERNAL_URL_RE,
  EXT_RE,
  HASH_RE,
  PATHNAME_PROTOCOL_RE,
  editLinkPatterns,
  getCssValue,
  getScrollTop,
  inBrowser,
  isActive,
  linear,
  normalize,
  normalizeLink,
  normalizePrefix,
  resolveEditLink,
  resolveNavLink,
  resolveRepoType,
  scrollTo,
  setScrollTop,
  throttleAndDebounce,
  toArray,
  tween
};

// src/node/plugin.ts
import { addViteOptimizeDepsInclude } from "@vuepress/helper";

// src/node/features/caniuse.ts
import container from "markdown-it-container";
import { customAlphabet } from "nanoid";

// src/node/utils/createRuleBlock.ts
function createRuleBlock(md, {
  type,
  name = type,
  syntaxPattern,
  beforeName = "import_code",
  ruleOptions = { alt: ["paragraph", "reference", "blockquote", "list"] },
  meta,
  content
}) {
  const MIN_LENGTH = type.length + 5;
  const START_CODES = [64, 91, ...type.split("").map((c) => c.charCodeAt(0))];
  md.block.ruler.before(
    beforeName,
    name,
    (state, startLine, endLine, silent) => {
      const pos = state.bMarks[startLine] + state.tShift[startLine];
      const max = state.eMarks[startLine];
      if (pos + MIN_LENGTH > max)
        return false;
      for (let i = 0; i < START_CODES.length; i += 1) {
        if (state.src.charCodeAt(pos + i) !== START_CODES[i])
          return false;
      }
      const match = state.src.slice(pos, max).match(syntaxPattern);
      if (!match)
        return false;
      if (silent)
        return true;
      const token = state.push(name, "", 0);
      token.meta = meta(match);
      token.map = [startLine, startLine + 1];
      state.line = startLine + 1;
      return true;
    },
    ruleOptions
  );
  md.renderer.rules[name] = (tokens, index) => {
    const token = tokens[index];
    token.content = content(token.meta);
    return token.content;
  };
}

// src/node/features/caniuse.ts
var nanoid = customAlphabet("abcdefghijklmnopqrstuvwxyz", 5);
var UNDERLINE_RE = /_+/g;
var caniusePlugin = (md, { mode: defaultMode = "embed" } = {}) => {
  createRuleBlock(md, {
    type: "caniuse",
    syntaxPattern: /^@\[caniuse\s*(embed|image)?(?:\{([0-9,\-]*)\})?\]\(([^)]*)\)/,
    meta: ([, mode, versions = "", feature]) => ({
      feature,
      mode: mode || defaultMode,
      versions
    }),
    content: (meta) => resolveCanIUse(meta)
  });
};
function legacyCaniuse(md, { mode = "embed" } = {}) {
  const modeMap = ["image", "embed"];
  const isMode = (mode2) => modeMap.includes(mode2);
  mode = isMode(mode) ? mode : modeMap[0];
  const type = "caniuse";
  const validateReg = new RegExp(`^${type}`);
  const validate = (info) => {
    return validateReg.test(info.trim());
  };
  const render = (tokens, index) => {
    const token = tokens[index];
    if (token.nesting === 1) {
      const info = token.info.trim().slice(type.length).trim() || "";
      const feature = info.split(/\s+/)[0];
      const versions = info.match(/\{(.*)\}/)?.[1] || "";
      return feature ? resolveCanIUse({ feature, mode, versions }) : "";
    } else {
      return "";
    }
  };
  md.use(container, type, { validate, render });
}
function resolveCanIUse({ feature, mode, versions }) {
  if (!feature)
    return "";
  if (mode === "image") {
    const link = "https://caniuse.bitsofco.de/image/";
    const alt = `Data on support for the ${feature} feature across the major browsers from caniuse.com`;
    return `<ClientOnly><p><picture>
      <source type="image/webp" srcset="${link}${feature}.webp">
      <source type="image/png" srcset="${link}${feature}.png">
      <img src="${link}${feature}.jpg" alt="${alt}" width="100%">
    </picture></p></ClientOnly>`;
  }
  feature = feature.replace(UNDERLINE_RE, "_");
  const { past, future } = resolveVersions(versions);
  const meta = nanoid();
  return `<CanIUseViewer feature="${feature}" meta="${meta}" past="${past}" future="${future}" />`;
}
function resolveVersions(versions) {
  if (!versions)
    return { past: 2, future: 1 };
  const list = versions.split(",").map((v) => Number(v.trim())).filter((v) => !Number.isNaN(v) && v >= -5 && v <= 3);
  list.push(0);
  const uniq = [...new Set(list)].sort((a, b) => b - a);
  return {
    future: uniq[0],
    past: Math.abs(uniq[uniq.length - 1])
  };
}

// src/node/features/pdf.ts
import { path } from "vuepress/utils";

// src/node/utils/resolveAttrs.ts
var RE_ATTR_VALUE = /(?:^|\s+)(?<attr>[\w-]+)(?:=\s*(?<quote>['"])(?<value>.+?)\k<quote>)?(?:\s+|$)/;
function resolveAttrs(info) {
  info = info.trim();
  if (!info)
    return { rawAttrs: "", attrs: {} };
  const attrs = {};
  const rawAttrs = info;
  let matched;
  while (matched = info.match(RE_ATTR_VALUE)) {
    const { attr, value } = matched.groups || {};
    attrs[attr] = value ?? true;
    info = info.slice(matched[0].length);
  }
  Object.keys(attrs).forEach((key) => {
    let value = attrs[key];
    value = typeof value === "string" ? value.trim() : value;
    if (value === "true")
      value = true;
    else if (value === "false")
      value = false;
    attrs[key] = value;
    if (key.includes("-")) {
      const _key = key.replace(/-(\w)/g, (_, c) => c.toUpperCase());
      attrs[_key] = value;
    }
  });
  return { attrs, rawAttrs };
}

// src/node/utils/parseRect.ts
function parseRect(str, unit = "px") {
  if (Number.parseFloat(str) === Number(str))
    return `${str}${unit}`;
  return str;
}

// src/node/features/pdf.ts
var pdfPlugin = (md) => {
  createRuleBlock(md, {
    type: "pdf",
    // eslint-disable-next-line regexp/no-super-linear-backtracking
    syntaxPattern: /^@\[pdf(?:\s+(\d+))?([^\]]*)\]\(([^)]*)\)/,
    meta([, page, info = "", src = ""]) {
      const { attrs } = resolveAttrs(info);
      return {
        src,
        page: +page || 1,
        noToolbar: Boolean(attrs.noToolbar ?? false),
        zoom: +attrs.zoom || 50,
        width: attrs.width ? parseRect(attrs.width) : "100%",
        height: attrs.height ? parseRect(attrs.height) : "",
        ratio: attrs.ratio ? parseRect(attrs.ratio) : "",
        title: path.basename(src || "")
      };
    },
    content({ title, src, page, noToolbar, width, height, ratio, zoom }) {
      return `<PDFViewer src="${src}" title="${title}" :page="${page}" :no-toolbar="${noToolbar}" width="${width}" height="${height}" ratio="${ratio}" :zoom="${zoom}" />`;
    }
  });
};

// src/node/features/icons/writer.ts
import { constants, promises as fsp } from "node:fs";
import { getIconContentCSS, getIconData } from "@iconify/utils";
import { fs, logger } from "vuepress/utils";
import { isPackageExists } from "local-pkg";
import { customAlphabet as customAlphabet2 } from "nanoid";

// src/node/utils/package.ts
async function interopDefault(m) {
  const resolved = await m;
  return resolved.default || resolved;
}

// src/node/features/icons/writer.ts
var nanoid2 = customAlphabet2("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 8);
var iconDataCache = /* @__PURE__ */ new Map();
var URL_CONTENT_RE = /(url\([\s\S]+?\))/;
var CSS_PATH = "internal/md-power/icons.css";
function resolveOption(opt) {
  const options = typeof opt === "object" ? opt : {};
  options.prefix ??= "vp-mdi";
  options.color = options.color === "currentColor" || !options.color ? "currentcolor" : options.color;
  options.size = options.size ? parseRect(`${options.size}`) : "1em";
  return options;
}
function createIconCSSWriter(app, opt) {
  const cache = /* @__PURE__ */ new Map();
  const isInstalled = isPackageExists("@iconify/json");
  const currentPath = app.dir.temp(CSS_PATH);
  const write = async (content) => {
    if (!content && app.env.isDev) {
      if (existsSync(currentPath) && (await fsp.stat(currentPath)).isFile()) {
        return;
      }
    }
    await app.writeTemp(CSS_PATH, content);
  };
  let timer = null;
  const options = resolveOption(opt);
  const prefix = options.prefix;
  const defaultContent = getDefaultContent(options);
  async function writeCss() {
    if (timer)
      clearTimeout(timer);
    timer = setTimeout(async () => {
      let css = defaultContent;
      if (cache.size > 0) {
        for (const [, { content, className }] of cache)
          css += `.${className} {
  --svg: ${content};
}
`;
        await write(css);
      }
    }, 100);
  }
  function addIcon(iconName) {
    if (!isInstalled)
      return;
    if (cache.has(iconName))
      return cache.get(iconName).className;
    const item = {
      className: `${prefix}-${nanoid2()}`,
      content: ""
    };
    cache.set(iconName, item);
    genIconContent(iconName, (content) => {
      item.content = content;
      writeCss();
    });
    return item.className;
  }
  async function initIcon() {
    if (!opt)
      return await write("");
    if (!isInstalled) {
      logger.error("[plugin-md-power]: `@iconify/json` not found! Please install `@iconify/json` first.");
      return;
    }
    return await writeCss();
  }
  return { addIcon, writeCss, initIcon };
}
function getDefaultContent(options) {
  const { prefix, size, color } = options;
  return `[class^="${prefix}-"],
[class*=" ${prefix}-"] {
  display: inline-block;
  width: ${size};
  height: ${size};
  vertical-align: middle;
  color: inherit;
  background-color: ${color};
  -webkit-mask: var(--svg) no-repeat;
  mask: var(--svg) no-repeat;
  -webkit-mask-size: 100% 100%;
  mask-size: 100% 100%;
}
`;
}
var locate;
async function genIconContent(iconName, cb) {
  if (!locate) {
    const mod = await interopDefault(import("@iconify/json"));
    locate = mod.locate;
  }
  const [collect, name] = iconName.split(":");
  let iconJson = iconDataCache.get(collect);
  if (!iconJson) {
    const filename = locate(collect);
    try {
      iconJson = JSON.parse(await fs.readFile(filename, "utf-8"));
      iconDataCache.set(collect, iconJson);
    } catch {
      logger.warn(`[plugin-md-power] Can not find icon, ${collect} is missing!`);
    }
  }
  const data = getIconData(iconJson, name);
  if (!data)
    return logger.error(`[plugin-md-power] Can not read icon in ${collect}, ${name} is missing!`);
  const content = getIconContentCSS(data, {
    height: data.height || 24
  });
  const match = content.match(URL_CONTENT_RE);
  return cb(match ? match[1] : "");
}
function existsSync(fp) {
  try {
    fs.accessSync(fp, constants.R_OK);
    return true;
  } catch {
    return false;
  }
}

// src/node/features/icons/plugin.ts
var [openTag, endTag] = [":[", "]:"];
function createTokenizer(addIcon) {
  return (state, silent) => {
    let found = false;
    const max = state.posMax;
    const start = state.pos;
    if (state.src.slice(start, start + 2) !== openTag)
      return false;
    if (silent)
      return false;
    if (max - start < 5)
      return false;
    state.pos = start + 2;
    while (state.pos < max) {
      if (state.src.slice(state.pos, state.pos + 2) === endTag) {
        found = true;
        break;
      }
      state.md.inline.skipToken(state);
    }
    if (!found || start + 2 === state.pos) {
      state.pos = start;
      return false;
    }
    const content = state.src.slice(start + 2, state.pos);
    if (/^\s|\s$/.test(content)) {
      state.pos = start;
      return false;
    }
    state.posMax = state.pos;
    state.pos = start + 2;
    const [iconName, options = ""] = content.split(/\s+/);
    const [size, color] = options.split("/");
    const open = state.push("iconify_open", "span", 1);
    open.markup = openTag;
    const className = addIcon(iconName);
    if (className)
      open.attrSet("class", className);
    let style = "";
    if (size)
      style += `width:${parseRect(size)};height:${parseRect(size)};`;
    if (color)
      style += `color:${color};`;
    if (style)
      open.attrSet("style", style);
    const text = state.push("text", "", 0);
    text.content = className ? "" : iconName;
    const close = state.push("iconify_close", "span", -1);
    close.markup = endTag;
    state.pos = state.posMax + 2;
    state.posMax = max;
    return true;
  };
}
var iconsPlugin = (md, addIcon = () => "") => {
  md.inline.ruler.before("emphasis", "iconify", createTokenizer(addIcon));
};

// src/node/features/video/bilibili.ts
import { URLSearchParams as URLSearchParams2 } from "node:url";

// src/node/utils/timeToSeconds.ts
function timeToSeconds(time) {
  if (!time)
    return 0;
  if (Number.parseFloat(time) === Number(time))
    return Number(time);
  const [s, m, h] = time.split(":").reverse().map((n) => Number(n) || 0);
  return s + m * 60 + h * 3600;
}

// src/node/features/video/bilibili.ts
var BILIBILI_LINK = "https://player.bilibili.com/player.html";
var bilibiliPlugin = (md) => {
  createRuleBlock(md, {
    type: "bilibili",
    name: "video_bilibili",
    // eslint-disable-next-line regexp/no-super-linear-backtracking
    syntaxPattern: /^@\[bilibili(?:\s+p(\d+))?([^\]]*)\]\(([^)]*)\)/,
    meta([, page, info = "", source = ""]) {
      const { attrs } = resolveAttrs(info);
      const ids = source.trim().split(/\s+/);
      const bvid = ids.find((id) => id.startsWith("BV"));
      const [aid, cid] = ids.filter((id) => !id.startsWith("BV"));
      return {
        page: +page || 1,
        bvid,
        aid,
        cid,
        autoplay: attrs.autoplay ?? false,
        time: timeToSeconds(attrs.time),
        title: attrs.title,
        width: attrs.width ? parseRect(attrs.width) : "100%",
        height: attrs.height ? parseRect(attrs.height) : "",
        ratio: attrs.ratio ? parseRect(attrs.ratio) : ""
      };
    },
    content(meta) {
      const params = new URLSearchParams2();
      if (meta.bvid) {
        params.set("bvid", meta.bvid);
      }
      if (meta.aid) {
        params.set("aid", meta.aid);
      }
      if (meta.cid) {
        params.set("cid", meta.cid);
      }
      if (meta.page) {
        params.set("p", meta.page.toString());
      }
      if (meta.time) {
        params.set("t", meta.time.toString());
      }
      params.set("autoplay", meta.autoplay ? "1" : "0");
      const source = `${BILIBILI_LINK}?${params.toString()}`;
      return `<VideoBilibili src="${source}" width="${meta.width}" height="${meta.height}" ratio="${meta.ratio}" title="${meta.title}" />`;
    }
  });
};

// src/node/features/video/youtube.ts
import { URLSearchParams as URLSearchParams3 } from "node:url";
var YOUTUBE_LINK = "https://www.youtube.com/embed/";
var youtubePlugin = (md) => {
  createRuleBlock(md, {
    type: "youtube",
    name: "video_youtube",
    syntaxPattern: /^@\[youtube([^\]]*)\]\(([^)]*)\)/,
    meta([, info = "", id = ""]) {
      const { attrs } = resolveAttrs(info);
      return {
        id,
        autoplay: attrs.autoplay ?? false,
        loop: attrs.loop ?? false,
        start: timeToSeconds(attrs.start),
        end: timeToSeconds(attrs.end),
        title: attrs.title,
        width: attrs.width ? parseRect(attrs.width) : "100%",
        height: attrs.height ? parseRect(attrs.height) : "",
        ratio: attrs.ratio ? parseRect(attrs.ratio) : ""
      };
    },
    content(meta) {
      const params = new URLSearchParams3();
      if (meta.autoplay) {
        params.set("autoplay", "1");
      }
      if (meta.loop) {
        params.set("loop", "1");
      }
      if (meta.start) {
        params.set("start", meta.start.toString());
      }
      if (meta.end) {
        params.set("end", meta.end.toString());
      }
      const source = `${YOUTUBE_LINK}/${meta.id}?${params.toString()}`;
      return `<VideoYoutube src="${source}" width="${meta.width}" height="${meta.height}" ratio="${meta.ratio}" title="${meta.title}" />`;
    }
  });
};

// src/node/features/codepen.ts
var CODEPEN_LINK = "https://codepen.io/";
var codepenPlugin = (md) => {
  createRuleBlock(md, {
    type: "codepen",
    syntaxPattern: /^@\[codepen([^\]]*)\]\(([^)]*)\)/,
    meta: ([, info = "", source = ""]) => {
      const { attrs } = resolveAttrs(info);
      const [user, slash] = source.split("/");
      return {
        width: attrs.width ? parseRect(attrs.width) : "100%",
        height: attrs.height ? parseRect(attrs.height) : "400px",
        user,
        slash,
        title: attrs.title,
        preview: attrs.preview,
        editable: attrs.editable,
        tab: attrs.tab ?? "result",
        theme: attrs.theme
      };
    },
    content: (meta) => {
      const { title = "Codepen", height, width } = meta;
      const params = new URLSearchParams();
      if (meta.editable) {
        params.set("editable", "true");
      }
      if (meta.tab) {
        params.set("default-tab", meta.tab);
      }
      if (meta.theme) {
        params.set("theme-id", meta.theme);
      }
      const middle = meta.preview ? "/embed/preview/" : "/embed/";
      const link = `${CODEPEN_LINK}${meta.user}${middle}${meta.slash}?${params.toString()}`;
      const style = `width:${width};height:${height};margin:16px auto;border-radius:5px;`;
      return `<iframe class="code-pen-iframe-wrapper" src="${link}" title="${title}" style="${style}" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="${CODEPEN_LINK}${meta.user}/pen/${meta.slash}">${title}</a> by ${meta.user} (<a href="${CODEPEN_LINK}${meta.user}">@${meta.user}</a>) on <a href="${CODEPEN_LINK}">CodePen</a>.</iframe>`;
    }
  });
};

// src/node/features/replit.ts
var replitPlugin = (md) => {
  createRuleBlock(md, {
    type: "replit",
    syntaxPattern: /^@\[replit([^\]]*)\]\(([^)]*)\)/,
    meta: ([, info = "", source = ""]) => {
      const { attrs } = resolveAttrs(info);
      return {
        width: attrs.width ? parseRect(attrs.width) : "100%",
        height: attrs.height ? parseRect(attrs.height) : "450px",
        source: source.startsWith("@") ? source : `@${source}`,
        title: attrs.title,
        theme: attrs.theme || ""
      };
    },
    content({ title, height, width, source, theme }) {
      return `<ReplitViewer title="${title || ""}" height="${height}" width="${width}" source="${source}" theme="${theme}" />`;
    }
  });
};

// src/node/features/codeSandbox.ts
var codeSandboxPlugin = (md) => {
  createRuleBlock(md, {
    type: "codesandbox",
    syntaxPattern: /^@\[codesandbox(?:\s+(embed|button))?([^\]]*)\]\(([^)]*)\)/,
    meta([, type, info = "", source = ""]) {
      const { attrs } = resolveAttrs(info);
      const [profile, filepath2 = ""] = source.split("#");
      const [user, id] = profile.includes("/") ? profile.split("/") : ["", profile];
      return {
        width: attrs.width ? parseRect(attrs.width) : "100%",
        height: attrs.height ? parseRect(attrs.height) : "500px",
        user,
        id,
        title: attrs.title ?? "",
        console: attrs.console ?? false,
        navbar: attrs.navbar ?? true,
        layout: attrs.layout ?? "",
        type: type || "embed",
        filepath: filepath2
      };
    },
    content({ title, height, width, user, id, type, filepath: filepath2, console, navbar, layout }) {
      return `<CodeSandboxViewer title="${title}" height="${height}" width="${width}" user="${user}" id="${id}" type="${type}" filepath="${filepath2}" :console=${console} :navbar=${navbar} layout="${layout}" />`;
    }
  });
};

// src/node/features/jsfiddle.ts
var jsfiddlePlugin = (md) => {
  createRuleBlock(md, {
    type: "jsfiddle",
    syntaxPattern: /^@\[jsfiddle([^\]]*)\]\(([^)]*)\)/,
    meta([, info = "", source]) {
      const { attrs } = resolveAttrs(info);
      const [user, id] = source.split("/");
      return {
        width: attrs.width ? parseRect(attrs.width) : "100%",
        height: attrs.height ? parseRect(attrs.height) : "400px",
        user,
        id,
        title: attrs.title || "JS Fiddle",
        tab: attrs.tab?.replace(/\s+/g, "") || "js,css,html,result",
        theme: attrs.theme || "dark"
      };
    },
    content: ({ title = "JS Fiddle", height, width, user, id, tab, theme }) => {
      theme = theme === "dark" ? "/dark/" : "";
      const link = `https://jsfiddle.net/${user}/${id}/embedded/${tab}${theme}`;
      const style = `width:${width};height:${height};margin:16px auto;border:none;border-radius:5px;`;
      return `<iframe class="js-fiddle-iframe-wrapper" style="${style}" title="${title}" src="${link}" allowfullscreen="true" allowpaymentrequest="true"></iframe>`;
    }
  });
};

// src/node/features/plot.ts
var [openTag2, endTag2] = ["!!", "!!"];
function createTokenizer2() {
  return (state, silent) => {
    let found = false;
    const max = state.posMax;
    const start = state.pos;
    if (state.src.slice(start, start + 2) !== openTag2)
      return false;
    if (silent)
      return false;
    if (max - start < 5)
      return false;
    state.pos = start + 2;
    while (state.pos < max) {
      if (state.src.slice(state.pos - 1, state.pos + 1) === endTag2) {
        found = true;
        break;
      }
      state.md.inline.skipToken(state);
    }
    if (!found || start + 2 === state.pos) {
      state.pos = start;
      return false;
    }
    const content = state.src.slice(start + 2, state.pos - 1);
    if (/^\s|\s$/.test(content)) {
      state.pos = start;
      return false;
    }
    state.posMax = state.pos - 1;
    state.pos = start + 2;
    const open = state.push("plot_open", "Plot", 1);
    open.markup = openTag2;
    const text = state.push("text", "", 0);
    text.content = content;
    const close = state.push("plot_close", "Plot", -1);
    close.markup = endTag2;
    state.pos = state.posMax + 2;
    state.posMax = max;
    return true;
  };
}
var plotPlugin = (md) => {
  md.inline.ruler.before("emphasis", "plot", createTokenizer2());
};

// src/node/features/langRepl.ts
import container2 from "markdown-it-container";
import { fs as fs2, getDirname, path as path2 } from "vuepress/utils";
var RE_INFO = /^(#editable)?(.*)$/;
function createReplContainer(md, lang) {
  const type = `${lang}-repl`;
  const validate = (info) => info.trim().startsWith(type);
  const render = (tokens, index) => {
    const token = tokens[index];
    const info = token.info.trim().slice(type.length).trim() || "";
    const [, editable, title] = info.match(RE_INFO) ?? [];
    if (token.nesting === 1)
      return `<CodeRepl ${editable ? "editable" : ""} title="${title || `${lang} playground`}">`;
    else
      return "</CodeRepl>";
  };
  md.use(container2, type, { validate, render });
}
async function langReplPlugin(app, md, {
  theme,
  go = false,
  kotlin = false,
  rust = false
}) {
  if (kotlin) {
    createReplContainer(md, "kotlin");
  }
  if (go) {
    createReplContainer(md, "go");
  }
  if (rust) {
    createReplContainer(md, "rust");
  }
  theme ??= { light: "github-light", dark: "github-dark" };
  const data = { grammars: {} };
  const themesPath = getDirname(import.meta.resolve("tm-themes"));
  const grammarsPath = getDirname(import.meta.resolve("tm-grammars"));
  const readTheme = (theme2) => read(path2.join(themesPath, "themes", `${theme2}.json`));
  const readGrammar = (grammar) => read(path2.join(grammarsPath, "grammars", `${grammar}.json`));
  if (typeof theme === "string") {
    data.theme = await readTheme(theme);
  } else {
    data.theme = await Promise.all([
      readTheme(theme.light),
      readTheme(theme.dark)
    ]).then(([light, dark]) => ({ light, dark }));
  }
  if (kotlin)
    data.grammars.kotlin = await readGrammar("kotlin");
  if (go)
    data.grammars.go = await readGrammar("go");
  if (rust)
    data.grammars.rust = await readGrammar("rust");
  await app.writeTemp(
    "internal/md-power/replEditorData.js",
    `export default ${JSON.stringify(data, null, 2)}`
  );
}
async function read(file) {
  try {
    const content = await fs2.readFile(file, "utf-8");
    return JSON.parse(content);
  } catch {
  }
  return void 0;
}

// src/node/prepareConfigFile.ts
import { getDirname as getDirname2, path as path3 } from "vuepress/utils";
import { ensureEndingSlash } from "@vuepress/helper";
var { url: filepath } = import.meta;
var __dirname = getDirname2(filepath);
var CLIENT_FOLDER = ensureEndingSlash(
  path3.resolve(__dirname, "../client")
);
async function prepareConfigFile(app, options) {
  const imports = /* @__PURE__ */ new Set();
  const enhances = /* @__PURE__ */ new Set();
  imports.add(`import '@internal/md-power/icons.css'`);
  if (options.pdf) {
    imports.add(`import PDFViewer from '${CLIENT_FOLDER}components/PDFViewer.vue'`);
    enhances.add(`app.component('PDFViewer', PDFViewer)`);
  }
  if (options.bilibili) {
    imports.add(`import Bilibili from '${CLIENT_FOLDER}components/Bilibili.vue'`);
    enhances.add(`app.component('VideoBilibili', Bilibili)`);
  }
  if (options.youtube) {
    imports.add(`import Youtube from '${CLIENT_FOLDER}components/Youtube.vue'`);
    enhances.add(`app.component('VideoYoutube', Youtube)`);
  }
  if (options.replit) {
    imports.add(`import Replit from '${CLIENT_FOLDER}components/Replit.vue'`);
    enhances.add(`app.component('ReplitViewer', Replit)`);
  }
  if (options.codeSandbox) {
    imports.add(`import CodeSandbox from '${CLIENT_FOLDER}components/CodeSandbox.vue'`);
    enhances.add(`app.component('CodeSandboxViewer', CodeSandbox)`);
  }
  if (options.plot) {
    imports.add(`import Plot from '${CLIENT_FOLDER}components/Plot.vue'`);
    enhances.add(`app.component('Plot', Plot)`);
  }
  if (options.repl) {
    imports.add(`import CodeRepl from '${CLIENT_FOLDER}components/CodeRepl.vue'`);
    enhances.add(`app.component('CodeRepl', CodeRepl)`);
  }
  if (options.caniuse) {
    imports.add(`import CanIUse from '${CLIENT_FOLDER}components/CanIUse.vue'`);
    enhances.add(`app.component('CanIUseViewer', CanIUse)`);
  }
  return app.writeTemp(
    "md-power/config.js",
    `import { defineClientConfig } from 'vuepress/client'
${Array.from(imports.values()).join("\n")}

export default defineClientConfig({
  enhance({ router, app }) {
${Array.from(enhances.values()).map((item) => `    ${item}`).join("\n")}
  }
})
`
  );
}

// src/node/plugin.ts
function markdownPowerPlugin(options = {}) {
  return (app) => {
    const { initIcon, addIcon } = createIconCSSWriter(app, options.icons);
    return {
      name: "vuepress-plugin-md-power",
      // clientConfigFile: path.resolve(__dirname, '../client/config.js'),
      clientConfigFile: (app2) => prepareConfigFile(app2, options),
      define: {
        __MD_POWER_INJECT_OPTIONS__: options
      },
      onInitialized: async () => await initIcon(),
      extendsBundlerOptions(bundlerOptions) {
        if (options.repl) {
          addViteOptimizeDepsInclude(
            bundlerOptions,
            app,
            ["shiki/core", "shiki/wasm"]
          );
        }
      },
      extendsMarkdown: async (md, app2) => {
        if (options.caniuse) {
          const caniuse = options.caniuse === true ? {} : options.caniuse;
          md.use(caniusePlugin, caniuse);
          legacyCaniuse(md, caniuse);
        }
        if (options.pdf) {
          md.use(pdfPlugin);
        }
        if (options.icons) {
          md.use(iconsPlugin, addIcon);
        }
        if (options.bilibili) {
          md.use(bilibiliPlugin);
        }
        if (options.youtube) {
          md.use(youtubePlugin);
        }
        if (options.codepen) {
          md.use(codepenPlugin);
        }
        if (options.replit) {
          md.use(replitPlugin);
        }
        if (options.codeSandbox) {
          md.use(codeSandboxPlugin);
        }
        if (options.jsfiddle) {
          md.use(jsfiddlePlugin);
        }
        if (options.plot === true || typeof options.plot === "object" && options.plot.tag !== false) {
          md.use(plotPlugin);
        }
        if (options.repl)
          await langReplPlugin(app2, md, options.repl);
      }
    };
  };
}
export {
  markdownPowerPlugin
};

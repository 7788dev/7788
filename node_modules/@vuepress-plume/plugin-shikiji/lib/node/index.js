// src/node/shikiPlugin.ts
import { getDirname as getDirname2 } from "vuepress/utils";
import { isPlainObject as isPlainObject2 } from "vuepress/shared";

// src/node/highlight.ts
import { colors as c, logger } from "vuepress/utils";
import { customAlphabet } from "nanoid";
import {
  addClassToHast,
  bundledLanguages,
  createHighlighter,
  isPlainLang,
  isSpecialLang
} from "shiki";
import {
  transformerCompactLineOptions,
  transformerNotationDiff,
  transformerNotationErrorLevel,
  transformerNotationFocus,
  transformerNotationHighlight,
  transformerNotationWordHighlight,
  transformerRemoveNotationEscape,
  transformerRenderWhitespace
} from "@shikijs/transformers";

// src/node/utils/attrsToLines.ts
function attrsToLines(attrs) {
  attrs = attrs.replace(/^(?:\[.*?\])?.*?([\d,-]+).*/, "$1").trim();
  const result = [];
  if (!attrs)
    return [];
  attrs.split(",").map((v) => v.split("-").map((v2) => Number.parseInt(v2, 10))).forEach(([start, end]) => {
    if (start && end) {
      result.push(
        ...Array.from({ length: end - start + 1 }, (_, i) => start + i)
      );
    } else {
      result.push(start);
    }
  });
  return result.map((line) => ({
    line,
    classes: ["highlighted"]
  }));
}

// src/node/utils/resolveAttr.ts
function resolveAttr(info, attr) {
  const pattern = `\\b${attr}\\s*=\\s*(?<quote>['"])(?<content>.+?)\\k<quote>(\\s|$)`;
  const regex = new RegExp(pattern, "i");
  const match = info.match(regex);
  return match?.groups?.content ?? null;
}

// src/node/utils/resolveLanguage.ts
var VUE_RE = /-vue$/;
function resolveLanguage(info) {
  return info.match(/^([^ :[{]+)/)?.[1]?.replace(VUE_RE, "").toLowerCase() ?? "";
}

// src/node/utils/lru.ts
var LRUCache = class {
  max;
  cache;
  constructor(max = 10) {
    this.max = max;
    this.cache = /* @__PURE__ */ new Map();
  }
  get(key) {
    const item = this.cache.get(key);
    if (item !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, item);
    }
    return item;
  }
  set(key, val) {
    if (this.cache.has(key))
      this.cache.delete(key);
    else if (this.cache.size === this.max)
      this.cache.delete(this.first());
    this.cache.set(key, val);
  }
  first() {
    return this.cache.keys().next().value;
  }
  clear() {
    this.cache.clear();
  }
};

// src/node/twoslash/rendererTransformer.ts
import { createTransformerFactory } from "@shikijs/twoslash/core";
import { createTwoslasher } from "twoslash-vue";
import { removeTwoslashNotations } from "twoslash";

// src/node/twoslash/renderer-floating-vue.ts
import { defaultHoverInfoProcessor, rendererRich } from "@shikijs/twoslash";
import { gfmFromMarkdown } from "mdast-util-gfm";
import { fromMarkdown } from "mdast-util-from-markdown";
import { defaultHandlers, toHast } from "mdast-util-to-hast";
function rendererFloatingVue(options = {}) {
  const {
    classCopyIgnore = "vp-copy-ignore",
    classFloatingPanel = "twoslash-floating",
    classCode = "vp-code",
    classMarkdown = "plume-content",
    floatingVueTheme = "twoslash",
    floatingVueThemeQuery = "twoslash-query",
    floatingVueThemeCompletion = "twoslash-completion"
  } = options.floatingVue || {};
  const {
    errorRendering = "line"
  } = options;
  const hoverBasicProps = {
    "class": "twoslash-hover",
    "popper-class": ["shiki", classFloatingPanel, classCopyIgnore, classCode].join(" "),
    "theme": floatingVueTheme
  };
  function compose(parts) {
    return [
      {
        type: "element",
        tagName: "span",
        properties: {},
        children: [parts.token]
      },
      {
        type: "element",
        tagName: "template",
        properties: {
          "v-slot:popper": "{}"
        },
        content: {
          type: "root",
          children: [vPre(parts.popup)]
        },
        children: []
      }
    ];
  }
  const rich = rendererRich({
    classExtra: classCopyIgnore,
    ...options,
    renderMarkdown,
    renderMarkdownInline,
    hast: {
      hoverToken: {
        tagName: "v-menu",
        properties: hoverBasicProps
      },
      hoverCompose: compose,
      queryToken: {
        tagName: "v-menu",
        properties: {
          ...hoverBasicProps,
          ":shown": "true",
          "theme": floatingVueThemeQuery
        }
      },
      queryCompose: compose,
      popupDocs: {
        class: `twoslash-popup-docs ${classMarkdown}`
      },
      popupDocsTags: {
        class: `twoslash-popup-docs twoslash-popup-docs-tags ${classMarkdown}`
      },
      popupError: {
        class: `twoslash-popup-error ${classMarkdown}`
      },
      errorToken: errorRendering === "line" ? void 0 : {
        tagName: "v-menu",
        properties: {
          ...hoverBasicProps,
          class: "twoslash-error twoslash-error-hover"
        }
      },
      errorCompose: compose,
      completionCompose({ popup, cursor }) {
        return [
          {
            type: "element",
            tagName: "v-menu",
            properties: {
              "popper-class": ["shiki twoslash-completion", classCopyIgnore, classFloatingPanel],
              "theme": floatingVueThemeCompletion,
              ":shown": "true"
            },
            children: [
              cursor,
              {
                type: "element",
                tagName: "template",
                properties: {
                  "v-slot:popper": "{}"
                },
                content: {
                  type: "root",
                  children: [vPre(popup)]
                }
              }
            ]
          }
        ];
      }
    }
  });
  return rich;
}
function vPre(el) {
  if (el.type === "element") {
    el.properties = el.properties || {};
    el.properties["v-pre"] = "";
  }
  return el;
}
function renderMarkdown(md) {
  const mdast = fromMarkdown(
    md.replace(/\{@link ([^}]*)\}/g, "$1"),
    // replace jsdoc links
    { mdastExtensions: [gfmFromMarkdown()] }
  );
  return toHast(
    mdast,
    {
      handlers: {
        code: (state, node) => {
          const lang = node.lang || "";
          if (lang) {
            return this.codeToHast(
              node.value,
              {
                ...this.options,
                transformers: [],
                lang
              }
            ).children[0];
          }
          return defaultHandlers.code(state, node);
        }
      }
    }
  ).children;
}
function renderMarkdownInline(md, context) {
  if (context === "tag:param")
    md = md.replace(/^([\w$-]+)/, "`$1` ");
  const children = renderMarkdown.call(this, md);
  if (children.length === 1 && children[0].type === "element" && children[0].tagName === "p")
    return children[0].children;
  return children;
}

// src/node/twoslash/rendererTransformer.ts
function transformerTwoslash(options = {}) {
  const {
    explicitTrigger = true
  } = options;
  const onError = (error, code) => {
    const isCI = typeof process !== "undefined" && process?.env?.CI;
    const isDev = typeof process !== "undefined" && process?.env?.NODE_ENV === "development";
    const shouldThrow = (options.throws || isCI || !isDev) && options.throws !== false;
    console.error(`

--------
Twoslash error in code:
--------
${code.split(/\n/g).slice(0, 15).join("\n").trim()}
--------
`);
    if (shouldThrow)
      throw error;
    else
      console.error(error);
    return removeTwoslashNotations(code);
  };
  const twoslash = createTransformerFactory(
    createTwoslasher()
  )({
    langs: ["ts", "tsx", "js", "jsx", "json", "vue"],
    renderer: rendererFloatingVue(options),
    onTwoslashError: onError,
    onShikiError: onError,
    ...options,
    explicitTrigger
  });
  return {
    ...twoslash,
    name: "@shiki/vuepress-twoslash",
    preprocess(code, options2) {
      const cleanup = options2.transformers?.find((i) => i.name === "vuepress:clean-up");
      if (cleanup)
        options2.transformers?.splice(options2.transformers.indexOf(cleanup), 1);
      return twoslash.preprocess.call(this, code, options2);
    },
    postprocess(html) {
      if (this.meta.twoslash)
        return html.replace(/\{/g, "&#123;");
      return html;
    }
  };
}

// src/node/highlight.ts
var nanoid = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
var cache = new LRUCache(64);
var vueRE = /-vue$/;
var mustacheRE = /\{\{.*?\}\}/g;
var decorationsRE = /^\/\/ @decorations:(.*)\n/;
async function highlight(theme, options, isDev) {
  const {
    defaultHighlightLang: defaultLang = "",
    codeTransformers: userTransformers = [],
    whitespace = false,
    languages = Object.keys(bundledLanguages)
  } = options;
  const highlighter = await createHighlighter({
    themes: typeof theme === "object" && "light" in theme && "dark" in theme ? [theme.light, theme.dark] : [theme],
    langs: languages,
    langAlias: options.languageAlias
  });
  await options?.shikiSetup?.(highlighter);
  const transformers = [
    transformerNotationDiff(),
    transformerNotationFocus({
      classActiveLine: "has-focus",
      classActivePre: "has-focused-lines"
    }),
    transformerNotationHighlight(),
    transformerNotationErrorLevel(),
    transformerNotationWordHighlight(),
    {
      name: "vuepress:add-class",
      pre(node) {
        addClassToHast(node, "vp-code");
      }
    },
    {
      name: "vuepress:clean-up",
      pre(node) {
        delete node.properties.tabindex;
        delete node.properties.style;
      }
    },
    {
      name: "shiki:inline-decorations",
      preprocess(code, options2) {
        code = code.replace(decorationsRE, (match, decorations) => {
          options2.decorations ||= [];
          options2.decorations.push(...JSON.parse(decorations));
          return "";
        });
        return code;
      }
    },
    transformerRemoveNotationEscape()
  ];
  const loadedLanguages = highlighter.getLoadedLanguages();
  return (str, language, attrs) => {
    attrs = attrs || "";
    let lang = resolveLanguage(language) || defaultLang;
    const vPre2 = vueRE.test(lang) ? "" : "v-pre";
    const key = str + language + attrs;
    if (isDev) {
      const rendered = cache.get(key);
      if (rendered)
        return rendered;
    }
    if (lang) {
      const langLoaded = loadedLanguages.includes(lang);
      if (!langLoaded && !isPlainLang(lang) && !isSpecialLang(lang)) {
        logger.warn(
          c.yellow(
            `
The language '${lang}' is not loaded, falling back to '${defaultLang || "txt"}' for syntax highlighting.`
          )
        );
        lang = defaultLang;
      }
    }
    const enabledTwoslash = attrs.includes("twoslash");
    const mustaches = /* @__PURE__ */ new Map();
    const removeMustache = (s) => {
      return s.replace(mustacheRE, (match) => {
        let marker = mustaches.get(match);
        if (!marker) {
          marker = nanoid();
          mustaches.set(match, marker);
        }
        return marker;
      });
    };
    const restoreMustache = (s) => {
      mustaches.forEach((marker, match) => {
        s = s.replaceAll(marker, match);
      });
      if (enabledTwoslash && options.twoslash)
        s = s.replace(/\{/g, "&#123;");
      return `${s}
`;
    };
    str = removeMustache(str).trimEnd();
    const inlineTransformers = [
      transformerCompactLineOptions(attrsToLines(attrs))
    ];
    if (enabledTwoslash && options.twoslash) {
      inlineTransformers.push(transformerTwoslash({
        processHoverInfo(info) {
          return defaultHoverInfoProcessor(info);
        }
      }));
    } else {
      inlineTransformers.push({
        name: "vuepress:v-pre",
        pre(node) {
          if (vPre2)
            node.properties["v-pre"] = "";
        }
      });
    }
    if (attrs.includes("whitespace") || whitespace)
      inlineTransformers.push(transformerRenderWhitespace({ position: "boundary" }));
    try {
      const highlighted = highlighter.codeToHtml(str, {
        lang,
        transformers: [
          ...transformers,
          ...inlineTransformers,
          ...userTransformers
        ],
        meta: { __raw: attrs },
        ...typeof theme === "object" && "light" in theme && "dark" in theme ? { themes: theme, defaultColor: false } : { theme }
      });
      const rendered = restoreMustache(highlighted);
      if (isDev)
        cache.set(key, rendered);
      return rendered;
    } catch (e) {
      logger.error(e);
      return str;
    }
  };
}

// src/node/markdown/highlightLinesPlugin.ts
var HIGHLIGHT_LINES_REGEXP = /\{([\d,-]+)\}/;
function highlightLinesPlugin(md) {
  const rawFence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, idx] = args;
    const token = tokens[idx];
    let lines = null;
    const rawInfo = token.info;
    const result = rawInfo?.match(HIGHLIGHT_LINES_REGEXP);
    if (!result)
      return rawFence(...args);
    token.info = rawInfo.replace(HIGHLIGHT_LINES_REGEXP, "").trim();
    lines = result[1];
    token.info += ` ${lines}`;
    return rawFence(...args);
  };
}

// src/node/markdown/lineNumberPlugin.ts
var LINE_NUMBERS_REGEXP = /:line-numbers\b/;
var NO_LINE_NUMBERS_REGEXP = /:no-line-numbers\b/;
var LINE_NUMBERS_START_REGEXP = /:line-numbers=(\d+)\b/;
function lineNumberPlugin(md, { lineNumbers = true } = {}) {
  const rawFence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const rawCode = rawFence(...args);
    const [tokens, idx] = args;
    const info = tokens[idx].info;
    const enableLineNumbers = LINE_NUMBERS_REGEXP.test(info);
    const disableLineNumbers = NO_LINE_NUMBERS_REGEXP.test(info);
    if (info.includes("twoslash"))
      return rawCode;
    if (!lineNumbers && !enableLineNumbers || lineNumbers && disableLineNumbers) {
      return rawCode;
    }
    const code = rawCode.slice(
      rawCode.indexOf("<code>"),
      rawCode.indexOf("</code>")
    );
    const lines = code.split("\n");
    if (typeof lineNumbers === "number" && lines.length < lineNumbers && !enableLineNumbers) {
      return rawCode;
    }
    const startNumbers = Number(info.match(LINE_NUMBERS_START_REGEXP)?.[1] ?? 1) - 1;
    const lineNumbersStyle = `style="counter-reset:line-number ${startNumbers}"`;
    const lineNumbersCode = [...Array(lines.length)].map(() => `<div class="line-number"></div>`).join("");
    const lineNumbersWrapperCode = `<div class="line-numbers" aria-hidden="true" ${lineNumbersStyle}>${lineNumbersCode}</div>`;
    const finalCode = rawCode.replace(/<\/div>$/, `${lineNumbersWrapperCode}</div>`).replace(/"(language-[^"]*)"/, '"$1 line-numbers-mode"');
    return finalCode;
  };
}

// src/node/markdown/preWrapperPlugin.ts
function preWrapperPlugin(md, { preWrapper = true } = {}) {
  const rawFence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [tokens, idx, options] = args;
    const token = tokens[idx];
    const info = token.info ? md.utils.unescapeAll(token.info).trim() : "";
    const lang = resolveLanguage(info);
    const title = resolveAttr(info, "title") || lang;
    const languageClass = `${options.langPrefix}${lang}`;
    let result = rawFence(...args);
    if (!preWrapper) {
      result = result.replace(/<code[\s\S]*?>/, "<code>");
      result = `<pre class="${languageClass}"${result.slice("<pre".length)}`;
      return result;
    }
    return `<div class="${languageClass}" data-ext="${lang}" data-title="${title}">${result}</div>`;
  };
}

// src/node/copy-code-button/createCopyCodeButtonRender.ts
import {
  getLocalePaths,
  getRootLangPath,
  isPlainObject
} from "@vuepress/helper";
import { ensureLeadingSlash, resolveLocalePath } from "vuepress/shared";

// src/node/copy-code-button/copyCodeButtonLocales.ts
var copyCodeButtonLocales = {
  "/en/": {
    title: "Copy code",
    copied: "Copied"
  },
  "/zh/": {
    title: "\u590D\u5236\u4EE3\u7801",
    copied: "\u5DF2\u590D\u5236"
  },
  "/zh-tw/": {
    title: "\u8907\u88FD\u4EE3\u78BC",
    copied: "\u5DF2\u8907\u88FD"
  },
  "/de/": {
    title: "Kopiere den Code.",
    copied: "Kopiert"
  },
  "/de-at/": {
    title: "Kopiere den Code.",
    copied: "Kopierter"
  },
  "/vi/": {
    title: "Sao ch\xE9p code",
    copied: "\u0110\xE3 sao ch\xE9p"
  },
  "/uk/": {
    title: "\u0421\u043A\u043E\u043F\u0456\u044E\u0439\u0442\u0435 \u043A\u043E\u0434",
    copied: "\u0421\u043A\u043E\u043F\u0456\u0439\u043E\u0432\u0430\u043D\u043E"
  },
  "/ru/": {
    title: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u043E\u0434",
    copied: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043E"
  },
  "/br/": {
    title: "Copiar o c\xF3digo",
    copied: "C\xF3digo"
  },
  "/pl/": {
    title: "Skopiuj kod",
    copied: "Skopiowane"
  },
  "/sk/": {
    title: "Skop\xEDruj k\xF3d",
    copied: "Skop\xEDrovan\xE9"
  },
  "/fr/": {
    title: "Copier le code",
    copied: "Copi\xE9"
  },
  "/es/": {
    title: "Copiar c\xF3digo",
    copied: "Copiado"
  },
  "/ja/": {
    title: "\u30B3\u30FC\u30C9\u3092\u30B3\u30D4\u30FC",
    copied: "\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F"
  },
  "/tr/": {
    title: "Kodu kopyala",
    copied: "Kopyaland\u0131"
  },
  "/ko/": {
    title: "\uCF54\uB4DC \uBCF5\uC0AC",
    copied: "\uBCF5\uC0AC\uB428"
  },
  "/fi/": {
    title: "Kopioi koodi",
    copied: "Kopioitu"
  },
  "/hu/": {
    title: "K\xF3d m\xE1sol\xE1sa",
    copied: "M\xE1solva"
  },
  "/id/": {
    title: "Salin kode",
    copied: "Disalin"
  },
  "/nl/": {
    title: "Kopieer code",
    copied: "Gekopieerd"
  }
};

// src/node/copy-code-button/createCopyCodeButtonRender.ts
function createCopyCodeButtonRender(app, options) {
  if (options === false)
    return null;
  const { className = "copy", locales: userLocales = {} } = isPlainObject(options) ? options : {};
  const root = getRootLangPath(app);
  const locales = {
    // fallback locale
    "/": userLocales["/"] || copyCodeButtonLocales[root]
  };
  getLocalePaths(app).forEach((path2) => {
    locales[path2] = userLocales[path2] || copyCodeButtonLocales[path2 === "/" ? root : path2];
  });
  return (filePathRelative) => {
    const relativePath = ensureLeadingSlash(filePathRelative ?? "");
    const localePath = resolveLocalePath(locales, relativePath);
    const { title, copied } = locales[localePath] ?? {};
    return `<button class="${className}" title="${title ?? "Copy code"}" data-copied="${copied ?? "Copied"}"></button>`;
  };
}

// src/node/copy-code-button/copyCodeButtonPlugin.ts
function copyCodeButtonPlugin(md, app, options) {
  const render = createCopyCodeButtonRender(app, options);
  if (!render)
    return;
  const fence = md.renderer.rules.fence;
  md.renderer.rules.fence = (...args) => {
    const [, , , env] = args;
    const result = fence(...args);
    const { filePathRelative } = env;
    const copyCodeButton = render(filePathRelative ?? "");
    return result.replace("><pre", `>${copyCodeButton}<pre`);
  };
}

// src/node/prepareClientConfigFile.ts
import { ensureEndingSlash } from "@vuepress/helper";
import { getDirname, path } from "vuepress/utils";
var __dirname = getDirname(import.meta.url);
var CLIENT_FOLDER = ensureEndingSlash(
  path.resolve(__dirname, "../client")
);
async function prepareClientConfigFile(app, {
  copyCode,
  twoslash
}) {
  return await app.writeTemp(
    "internal/plugin-shiki/client.js",
    `${twoslash ? `import { enhanceTwoslash } from '${CLIENT_FOLDER}composables/twoslash.js'` : ""}
${copyCode ? `import { useCopyCode } from '${CLIENT_FOLDER}composables/copy-code.js'` : ""}

export default {
  ${twoslash ? `enhance({ app }) {
    enhanceTwoslash(app)
  },` : ""}
  ${copyCode ? `setup() {
    useCopyCode({
      selector: __CC_SELECTOR__,
      duration: __CC_DURATION__,
    })
  },` : ""}
}
`
  );
}

// src/node/shikiPlugin.ts
var __dirname2 = getDirname2(import.meta.url);
function shikiPlugin({
  preWrapper = true,
  lineNumbers = true,
  copyCode = true,
  ...options
} = {}) {
  const copyCodeOptions = isPlainObject2(copyCode) ? copyCode : {};
  return {
    name: "@vuepress-plume/plugin-shikiji",
    define: {
      __CC_DURATION__: copyCodeOptions.duration ?? 2e3,
      __CC_SELECTOR__: `div[class*="language-"] > button.${copyCodeOptions.className || "copy"}`
    },
    clientConfigFile: (app) => prepareClientConfigFile(app, {
      copyCode: copyCode !== false,
      twoslash: options.twoslash ?? false
    }),
    extendsMarkdown: async (md, app) => {
      const theme = options.theme ?? { light: "github-light", dark: "github-dark" };
      md.options.highlight = await highlight(theme, options, app.env.isDev);
      md.use(highlightLinesPlugin);
      md.use(preWrapperPlugin, {
        preWrapper
      });
      if (preWrapper) {
        copyCodeButtonPlugin(md, app, copyCode);
        md.use(lineNumberPlugin, { lineNumbers });
      }
    },
    extendsMarkdownOptions: (options2) => {
      if (options2.vPre !== false) {
        const vPre2 = isPlainObject2(options2.vPre) ? options2.vPre : { block: true };
        if (vPre2.block) {
          options2.vPre ??= {};
          options2.vPre.block = false;
        }
      }
    }
  };
}

// src/node/index.ts
var node_default = shikiPlugin;
export {
  node_default as default,
  shikiPlugin
};
